#Google C ++スタイルガイド
## バックグラウンド
C ++は、Googleの多くのオープンソースプロジェクトで使用されている主要な開発言語の1つです。すべてのC ++プログラマーが知っているように、この言語には多くの強力な機能がありますが、この機能により複雑さが増し、コードがバグを起こしやすくなり、読み取りと保守が困難になる可能性があります。
このガイドの目的は、C ++コードを作成する際の注意事項と禁止事項を詳細に説明することにより、この複雑さを管理することです。これらのルールは、コードベースを管理しやすくすると同時に、コーダーがC ++言語機能を生産的に使用できるようにするために存在します。
可読性とも呼ばれる_Style_は、C ++コードを管理する規則と呼ばれるものです。これらの規則はソースファイルのフォーマットだけではないため、スタイルという用語は少し誤解されています。
Googleが開発したほとんどのオープンソースプロジェクトは、このガイドの要件に準拠しています。
このガイドはC ++チュートリアルではないことに注意してください。読者がこの言語に精通していることを前提としています。
###スタイルガイドの目標
なぜこのドキュメントがあるのですか？
このガイドが役立つと私たちが信じているいくつかの主要な目標があります。これらは、個々のルールすべての根底にある基本的な**理由**です。これらのアイデアを前面に出すことで、議論の根拠となり、ルールが適用されている理由と特定の決定が行われた理由をより広いコミュニティに明確にしたいと考えています。各ルールがどのような目標を達成しているのかを理解していれば、ルールが免除される時期（一部は免除される可能性があります）、およびガイドのルールを変更するために必要な議論や代替案が誰にでも明確になるはずです。
現在見ているスタイルガイドの目標は次のとおりです。
スタイルルールはその重みを引き出す必要があります
スタイルルールの利点は、すべてのエンジニアにそれを覚えてもらうことを正当化するのに十分な大きさでなければなりません。メリットは、ルールなしで取得するコードベースと比較して測定されるため、非常に有害なプラクティスに対するルールは、とにかくそうする可能性が低い場合でも、わずかなメリットしかありません。この原則は、私たちが持っているルールではなく、私たちが持っていないルールを主に説明しています。たとえば、「goto」は次の原則の多くに違反していますが、すでにほとんどなくなっているため、スタイルガイドでは説明していません。ライターではなく、リーダー向けに最適化する
私たちのコードベース（およびそれに提出されたほとんどの個々のコンポーネント）は、かなり長い間続くと予想されます。その結果、コードを書くよりも読むことに多くの時間が費やされます。私たちは、平均的なソフトウェアエンジニアがコードベースでコードを読み、維持し、デバッグする経験を、コードを書くときに簡単にするのではなく、最適化することを明示的に選択します。「読者に痕跡を残す」は、この原則の特に一般的なサブポイントです。コードのスニペットで驚くべきまたは異常なことが起こった場合（たとえば、ポインターの所有権の譲渡）、その時点で読者にテキストのヒントを残します使用することは価値があります（ `std :: unique_ptr`は、呼び出しサイトでの所有権の譲渡を明確に示しています）。既存のコードと一貫性を保つ
コードベース全体で一貫して1つのスタイルを使用すると、他の（より重要な）問題に集中できます。一貫性により、自動化も可能になります。コードをフォーマットしたり、 `#include`を調整したりするツールは、コードがツールの期待と一致している場合にのみ適切に機能します。多くの場合、「一貫性を保つ」に起因するルールは、「1つを選択して心配するのをやめる」に要約されます。これらの点に柔軟性を持たせることの潜在的な価値は、人々にそれらについて議論させるコストよりも重要です。必要に応じて、より広範なC ++コミュニティと一貫性を保つ
他の組織がC ++を使用する方法との一貫性は、コードベース内の一貫性と同じ理由で価値があります。C ++標準の機能が問題を解決する場合、またはいくつかのイディオムが広く知られ、受け入れられている場合、それはそれを使用するための議論です。ただし、標準機能やイディオムに欠陥がある場合や、コードベースのニーズを考慮せずに設計された場合があります。そのような場合（以下で説明）、標準機能を制約または禁止することが適切です。場合によっては、C ++標準で定義されたライブラリよりも、コードベースを標準インターフェイスに移行するための認識された優位性または不十分な値のいずれかから、自社製またはサードパーティのライブラリを優先します。意外なまたは危険な構成を避けてください
C ++には、一目で想像するよりも驚くべき、または危険な機能があります。これらの落とし穴に陥らないように、いくつかのスタイルガイドの制限が設けられています。そのようなルールを放棄することは、プログラムの正確性を損なうリスクを直接もたらすことが多いため、そのような制限に対するスタイルガイドの放棄には高い基準があります。私たちの平均的なC ++プログラマーが維持するのが難しいまたは難しいと感じる構造を避けてください
C ++には、コードに複雑さが伴うため、一般的に適切ではない可能性のある機能があります。広く使用されているコードでは、より複雑な実装の利点が使用法によって大幅に倍増し、複雑さを理解するためのコストを新しい部分で作業するときに再度支払う必要がないため、よりトリッキーな言語構造を使用する方が受け入れられる場合があります。コードベース。疑わしい場合は、プロジェクトリードに尋ねることで、このタイプのルールの免除を求めることができます。コードの所有権とチームメンバーシップは時間の経過とともに変化するため、これはコードベースにとって特に重要です。コードの一部を扱うすべての人が現在それを理解していても、そのような理解が数年後に続くとは限りません。私たちの規模に注意してください
1億行以上のコードベースと数千人のエンジニアがいるため、1人のエンジニアのミスや単純化は、多くの人にとってコストがかかる可能性があります。たとえば、グローバル名前空間の汚染を回避することは特に重要です。数億行のコードベース間での名前の衝突は、操作が難しく、全員がグローバル名前空間に配置すると回避が困難です。必要に応じて最適化を認める
パフォーマンスの最適化は、このドキュメントの他の原則と矛盾する場合でも、必要かつ適切な場合があります。
このドキュメントの目的は、合理的な制限付きで最大限のガイダンスを提供することです。いつものように、常識と美味しさが優先されるべきです。これにより、個人的な好みやチームの好みだけでなく、Google C ++コミュニティ全体で確立された規則を具体的に参照します。巧妙な構成や珍しい構成の使用には懐疑的であり、消極的です。禁止事項がないことは、続行するためのライセンスと同じではありません。あなたの判断を使用してください、そしてあなたが確信が持てないならば、あなたのプロジェクトリードに追加のインプットを得るために遠慮なく尋ねてください。
## C ++バージョン
現在、コードはC ++ 17をターゲットにする必要があります。つまり、C ++ 2x機能を使用しないでください。このガイドの対象となるC ++バージョンは、時間の経過とともに（積極的に）進歩します。
非標準の拡張機能は使用しないでください。
プロジェクトでC ++ 14およびC ++ 17の機能を使用する前に、他の環境への移植性を検討してください。
##ヘッダーファイル
一般に、すべての `.cc`ファイルには関連する` .h`ファイルが必要です。ユニットテストや、 `main（）`関数のみを含む小さな `.cc`ファイルなど、いくつかの一般的な例外があります。
ヘッダーファイルを正しく使用すると、コードの可読性、サイズ、パフォーマンスに大きな違いが生じる可能性があります。
次のルールは、ヘッダーファイルを使用する際のさまざまな落とし穴をガイドします。
###自己完結型ヘッダー
ヘッダーファイルは自己完結型（独自にコンパイル）で、 `.h`で終わる必要があります。インクルードを目的とした非ヘッダーファイルは、 `.inc`で終わり、慎重に使用する必要があります。
すべてのヘッダーファイルは自己完結型である必要があります。ユーザーとリファクタリングツールは、ヘッダーを含めるために特別な条件に従う必要はありません。具体的には、ヘッダーにはヘッダーガードがあり、必要な他のすべてのヘッダーを含める必要があります。
テンプレート関数とインライン関数の定義を、それらの宣言と同じファイルに配置することをお勧めします。これらの構成の定義は、それらを使用するすべての `.cc`ファイルに含める必要があります。そうしないと、プログラムが一部のビルド構成でリンクに失敗する可能性があります。宣言と定義が異なるファイルにある場合、前者を含めて、後者を推移的に含める必要があります。これらの定義を個別にインクルードされたヘッダーファイル（ `-inl.h`）に移動しないでください。この慣行は過去には一般的でしたが、現在は許可されていません。
例外として、関連するすべてのテンプレート引数のセットに対して明示的にインスタンス化されるテンプレート、またはクラスのプライベート実装の詳細であるテンプレートは、テンプレートをインスタンス化する唯一の `.cc`ファイルで定義できます。
含まれるように設計されたファイルが自己完結していないというまれなケースがあります。これらは通常、別のファイルの途中など、通常とは異なる場所に含めることを目的としています。ヘッダーガードを使用していない可能性があり、前提条件が含まれていない可能性があります。このようなファイルには、拡張子「.inc」を付けてください。慎重に使用し、可能な場合は自己完結型のヘッダーを優先してください。
### #define Guard
複数のインクルードを防ぐために、すべてのヘッダーファイルには `#define`ガードが必要です。シンボル名の形式は、 `_ <PROJECT> __ _ <PATH> __ _ <FILE> __H_`である必要があります。
一意性を保証するには、プロジェクトのソースツリーのフルパスに基づいている必要があります。たとえば、プロジェクト `foo`のファイル` foo / src / bar / baz.h`には、次のガードが必要です。
###使用するものを含める
ソースファイルまたはヘッダーファイルが他の場所で定義されたシンボルを参照している場合、ファイルには、そのシンボルの宣言または定義を適切に提供することを意図したヘッダーファイルを直接含める必要があります。その他の理由でヘッダーファイルをインクルードしないでください。
推移的な包含に依存しないでください。これにより、クライアントを壊すことなく、不要になった `#include`ステートメントをヘッダーから削除できます。これは関連するヘッダーにも当てはまります\ -`foo.h`に `bar.h`が含まれている場合でも、` foo.cc`にシンボルを使用する場合は `bar.h`を含める必要があります。
###前方宣言
可能な限り、前方宣言の使用は避けてください。代わりに、必要なヘッダーを含めてください。
「前方宣言」は、関連する定義のないエンティティの宣言です。
*前方宣言は、 `#include`によってコンパイラがより多くのファイルを開き、より多くの入力を処理するように強制するため、コンパイル時間を節約できます。*前方宣言により、不要な再コンパイルを節約できます。`#include`sは、ヘッダーの無関係な変更により、コードをより頻繁に再コンパイルするように強制する可能性があります。
*前方宣言により依存関係を非表示にできるため、ヘッダーが変更されたときにユーザーコードが必要な再コンパイルをスキップできます。* #includeステートメントとは対照的な前方宣言により、自動ツールがシンボルを定義するモジュールを検出することが困難になります。*前方宣言は、その後のライブラリへの変更によって破損する可能性があります。関数とテンプレートの前方宣言により、ヘッダーの所有者は、パラメータータイプの拡張、デフォルト値を使用したテンプレートパラメーターの追加、新しい名前空間への移行など、APIに互換性のある変更を加えることができなくなります。*名前空間 `std ::`からシンボルを前方宣言すると、未定義の動作が発生します。*前方宣言または完全な `#include`が必要かどうかを判断するのは難しい場合があります。`#include`を前方宣言に置き換えると、コードの意味を黙って変更できます。
`#include`が` B`と `D`の前方宣言に置き換えられた場合、` test（） `は` f（void *） `を呼び出します。
*ヘッダーから複数のシンボルを前方宣言することは、単にヘッダーを「#include」するよりも冗長になる可能性があります。*前方宣言を有効にするようにコードを構造化すると（たとえば、オブジェクトメンバーの代わりにポインターメンバーを使用すると）、コードが遅くなり、複雑になる可能性があります。
別のプロジェクトで定義されたエンティティの前方宣言は避けてください。
###インライン関数
関数をインラインで定義するのは、関数が小さい場合、たとえば10行以下の場合のみです。
通常の関数呼び出しメカニズムを介して関数を呼び出すのではなく、コンパイラーがインラインで関数を展開できるように関数を宣言できます。
関数をインライン化すると、インライン化された関数が小さい限り、より効率的なオブジェクトコードを生成できます。アクセサーとミューテーター、およびその他のパフォーマンスが重要な短い関数をインライン化してください。
インライン化を使いすぎると、実際にはプログラムが遅くなる可能性があります。関数のサイズに応じて、関数をインライン化すると、コードサイズが増減する可能性があります。非常に小さいアクセサ関数をインライン化すると、通常、コードサイズが小さくなりますが、非常に大きい関数をインライン化すると、コードサイズが劇的に大きくなる可能性があります。最近のプロセッサでは、命令キャッシュの使用率が高いため、通常、小さいコードの方が高速に実行されます。
適切な経験則は、関数が10行を超える場合はインライン化しないことです。暗黙的なメンバーおよびベースデストラクタ呼び出しのために、表示よりも長くなることが多いデストラクタに注意してください。
もう1つの便利なルール：ループまたはswitchステートメントを使用して関数をインライン化することは通常費用効果が高くありません（一般的なケースでは、loopまたはswitchステートメントが実行されない場合を除く）。
関数がそのように宣言されていても、関数が常にインライン化されるとは限らないことを知っておくことが重要です。たとえば、仮想関数と再帰関数は通常インライン化されていません。通常、再帰関数はインラインであってはなりません。仮想関数をインライン化する主な理由は、便宜上、またはアクセサーやミューテーターなどの動作を文書化するために、その定義をクラスに配置することです。
###インクルードの名前と順序
次の順序でヘッダーを含めます：関連ヘッダー、Cシステムヘッダー、C ++標準ライブラリヘッダー、他のライブラリのヘッダー、プロジェクトのヘッダー。
プロジェクトのすべてのヘッダーファイルは、UNIXディレクトリエイリアス `.`（現在のディレクトリ）または` ..`（親ディレクトリ）を使用せずに、プロジェクトのソースディレクトリの子孫としてリストする必要があります。たとえば、 `google-awesome-project / src / base / logging.h`は次のように含める必要があります。
`dir / foo.cc`または` dir / foo_test.cc`で、その主な目的は `dir2 / foo2.h`の内容を実装またはテストすることであり、次のようにインクルードを注文します。
1. `dir2 / foo2.h`。2.空白行3.Cシステムヘッダー（より正確には、 `.h`拡張子が付いた山括弧内のヘッダー）。例：` <unistd.h> `、` <stdlib.h> `。4.空白行5.C ++標準ライブラリヘッダー（ファイル拡張子なし）。例： `<algorithm>`、 `<cstddef>`。6.空白行
7.他のライブラリの `.h`ファイル。
8.プロジェクトの `.h`ファイル。
空でない各グループは、1行の空白行で区切ります。
優先順位では、関連するヘッダー `dir2 / foo2.h`で必要なインクルードが省略されている場合、` dir / foo.cc`または `dir / foo_test.cc`のビルドが中断されます。したがって、このルールにより、他のパッケージの無実の人々ではなく、これらのファイルで作業している人々にビルドブレークが最初に表示されるようになります。
`dir / foo.cc`と` dir2 / foo2.h`は通常同じディレクトリ（例： `base / basictypes_test.cc`と` base / basictypes.h`）にありますが、異なるディレクトリにある場合もあります。
`stddef.h`などのCヘッダーは、基本的にC ++の対応するヘッダー（` cstddef`）と互換性があることに注意してください。どちらのスタイルでもかまいませんが、既存のコードとの一貫性を優先します。
各セクション内では、インクルードをアルファベット順に並べる必要があります。古いコードはこのルールに準拠していない可能性があるため、都合のよいときに修正する必要があることに注意してください。
たとえば、 `google-awesome-project / src / foo / internal / fooserver.cc`のインクルードは次のようになります。
**例外：**
場合によっては、システム固有のコードに条件付きインクルードが必要です。このようなコードは、条件付きインクルードを他のインクルードの後に置くことができます。もちろん、システム固有のコードは小さく、ローカライズしてください。例：
##スコープ
###名前空間
いくつかの例外を除いて、名前空間にコードを配置します。名前空間には、プロジェクト名と、場合によってはそのパスに基づいた一意の名前を付ける必要があります。_using-ディレクティブ_を使用しないでください（例： `using namespace foo`）。インライン名前空間を使用しないでください。名前のない名前空間については、名前のない名前空間と静的変数を参照してください。
名前空間は、グローバルスコープを個別の名前付きスコープに分割するため、グローバルスコープでの名前の衝突を防ぐのに役立ちます。
名前空間は、大規模なプログラムでの名前の競合を防ぎ、ほとんどのコードで適度に短い名前を使用できるようにする方法を提供します。
たとえば、2つの異なるプロジェクトのグローバルスコープにクラス `Foo`がある場合、これらのシンボルはコンパイル時または実行時に衝突する可能性があります。各プロジェクトがコードを名前空間に配置する場合、 `project1 :: Foo`と` project2 :: Foo`は衝突しない別個のシンボルになり、各プロジェクトの名前空間内のコードはプレフィックスなしで引き続き `Foo`を参照できます。
インライン名前空間は、名前を囲んでいるスコープに自動的に配置します。たとえば、次のスニペットについて考えてみます。
式 `outer :: inner :: foo（）`と `outer :: foo（）`は交換可能です。インライン名前空間は、主にバージョン間のABI互換性を目的としています。
名前空間は、名前がどの定義を参照しているかを理解するメカニズムを複雑にするため、混乱を招く可能性があります。
特にインライン名前空間は、名前が宣言されている名前空間に実際に制限されていないため、混乱を招く可能性があります。これらは、いくつかのより大きなバージョン管理ポリシーの一部としてのみ役立ちます。
状況によっては、完全修飾名でシンボルを繰り返し参照する必要があります。深くネストされた名前空間の場合、これにより多くの混乱が生じる可能性があります。
名前空間は次のように使用する必要があります。
*名前空間名のルールに従います。*与えられた例に示されているように、コメントを使用して複数行の名前空間を終了します。*名前空間は、インクルード、[gflags]（https://gflags.github.io/gflags/）定義/宣言、および他の名前空間からのクラスの前方宣言の後にソースファイル全体をラップします。
より複雑な `.cc`ファイルには、フラグやusing-宣言などの追加の詳細が含まれる場合があります。
*生成されたプロトコルメッセージコードを名前空間に配置するには、 `.proto`ファイルの` package`指定子を使用します。詳細については、[プロトコルバッファパッケージ]（https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package）を参照してください。*標準ライブラリクラスの前方宣言を含め、名前空間 `std`で何も宣言しないでください。名前空間 `std`でエンティティを宣言することは未定義の動作です。つまり、移植性はありません。標準ライブラリからエンティティを宣言するには、適切なヘッダーファイルをインクルードします。*名前空間のすべての名前を使用可能にするために_using-directive_を使用することはできません。
*ヘッダーファイルの名前空間にインポートされたものはすべて、そのファイルによってエクスポートされたパブリックAPIの一部になるため、明示的にマークされた内部のみの名前空間を除いて、ヘッダーファイルの名前空間スコープで_Namespacealiases_を使用しないでください。
*インライン名前空間を使用しないでください。
###名前空間と静的変数
`.cc`ファイル内の定義をそのファイルの外部で参照する必要がない場合は、名前のない名前空間に配置するか、` static`として宣言します。`.h`ファイルではこれらの構成のいずれも使用しないでください。
すべての宣言は、名前のない名前空間に配置することで内部リンクを与えることができます。関数と変数は、それらを「静的」と宣言することにより、内部リンケージを与えることもできます。これは、宣言しているものは別のファイルからアクセスできないことを意味します。別のファイルが同じ名前の何かを宣言している場合、2つのエンティティは完全に独立しています。
他の場所で参照する必要のないすべてのコードでは、 `.cc`ファイルで内部リンケージを使用することをお勧めします。`.h`ファイルで内部リンケージを使用しないでください。
名前空間のような名前のない名前空間をフォーマットします。終了コメントで、名前空間名を空のままにします。
###非メンバー、静的メンバー、およびグローバル関数
非メンバー関数を名前空間に配置することをお勧めします。完全にグローバルな関数を使用することはめったにありません。静的メンバーをグループ化するためだけにクラスを使用しないでください。クラスの静的メソッドは、通常、クラスのインスタンスまたはクラスの静的データと密接に関連している必要があります。
非メンバー関数と静的メンバー関数は、状況によっては役立つ場合があります。非メンバー関数を名前空間に配置すると、グローバル名前空間の汚染を回避できます。
非メンバー関数と静的メンバー関数は、特に外部リソースにアクセスしたり、重要な依存関係がある場合は、新しいクラスのメンバーとしてより意味がある場合があります。
クラスインスタンスにバインドされていない関数を定義すると便利な場合があります。このような関数は、静的メンバーまたは非メンバー関数のいずれかです。非メンバー関数は外部変数に依存してはならず、ほとんどの場合、名前空間に存在する必要があります。静的メンバーをグループ化するためだけにクラスを作成しないでください。これは、名前に共通のプレフィックスを付けることと同じであり、そのようなグループ化は通常、とにかく不要です。
非メンバー関数を定義し、それがその `.cc`ファイルでのみ必要な場合は、内部リンケージを使用してそのスコープを制限します。
###ローカル変数
関数の変数を可能な限り狭いスコープに配置し、宣言で変数を初期化します。
C ++では、関数内の任意の場所で変数を宣言できます。可能な限りローカルなスコープで、可能な限り最初の使用に近い範囲で宣言することをお勧めします。これにより、読者は宣言を見つけて、変数のタイプと初期化されたものを簡単に確認できます。特に、宣言と割り当ての代わりに初期化を使用する必要があります。例：
`if`、` while`、および `for`ステートメントに必要な変数は、通常、これらのステートメント内で宣言する必要があります。そのため、このような変数はこれらのスコープに限定されます。例えば。：
注意点が1つあります。変数がオブジェクトの場合、スコープに入るたびにコンストラクタが呼び出されて作成され、スコープから出るたびにデストラクタが呼び出されます。
そのループの外側のループで使用されるそのような変数を宣言する方が効率的かもしれません：
###静的変数とグローバル変数
[静的ストレージ期間]（http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration）のオブジェクトは、[自明に破壊可能]（http://en.cppreference.com/w/）でない限り禁止されています。cpp / types / is_destructible）。非公式には、これは、メンバーおよびベースのデストラクタを考慮しても、デストラクタが何もしないことを意味します。より正式には、タイプにユーザー定義または仮想デストラクタがなく、すべてのベースおよび非静的メンバーが簡単に破壊可能であることを意味します。静的関数-ローカル変数は動的初期化を使用できます。静的クラスメンバー変数または名前空間スコープの変数に動的初期化を使用することはお勧めしませんが、限られた状況で許可されます。詳細については、以下を参照してください。
経験則として、グローバル変数は、その宣言が単独で考慮されて「constexpr」である可能性がある場合、これらの要件を満たします。
すべてのオブジェクトには、その存続期間と相関する保存期間があります。静的ストレージ期間を持つオブジェクトは、初期化の時点からプログラムの終了まで存続します。このようなオブジェクトは、名前空間スコープの変数（ "グローバル変数"）、クラスの静的データメンバー、または `static`指定子で宣言された関数ローカル変数として表示されます。関数ローカル静的変数は、制御が最初に宣言を通過するときに初期化されます。静的ストレージ期間を持つ他のすべてのオブジェクトは、プログラムの起動の一部として初期化されます。静的ストレージ期間を持つすべてのオブジェクトは、プログラムの終了時に破棄されます（これは、結合されていないスレッドが終了する前に発生します）。
初期化は動的である可能性があります。つまり、初期化中に重要なことが発生します。（たとえば、メモリを割り当てるコンストラクタ、または現在のプロセスIDで初期化される変数について考えてみます。）他の種類の初期化は静的初期化です。ただし、この2つは完全に反対ではありません。静的初期化は静的ストレージ期間のオブジェクトに対して発生します（オブジェクトを特定の定数またはゼロに設定されたすべてのバイトで構成される表現に対して初期化します）が、動的初期化はその後に発生します。必須。
グローバル変数と静的変数は、名前付き定数、一部の変換ユニットの内部の補助データ構造、コマンドラインフラグ、ロギング、登録メカニズム、バックグラウンドインフラストラクチャなど、多数のアプリケーションに非常に役立ちます。
動的初期化を使用する、または重要なデストラクタを持つグローバル変数と静的変数は複雑さを生み出し、簡単に見つけにくいバグにつながる可能性があります。動的初期化は変換ユニット間で順序付けられておらず、破棄も順序付けられていません（破棄が初期化の逆の順序で発生することを除いて）。ある初期化が静的ストレージ期間を持つ別の変数を参照する場合、これにより、オブジェクトの有効期間が開始する前（または有効期間が終了した後）にオブジェクトにアクセスする可能性があります。さらに、プログラムが終了時に結合されていないスレッドを開始すると、それらのスレッドは、デストラクタがすでに実行されている場合、ライフタイムが終了した後にオブジェクトにアクセスしようとする可能性があります。
####破壊に関する決定
デストラクタが些細なものである場合、その実行は順序付けの対象にはなりません（事実上「実行」されません）。そうしないと、オブジェクトの存続期間が終了した後、オブジェクトにアクセスするリスクにさらされます。したがって、静的な保存期間を持つオブジェクトは、簡単に破壊できる場合にのみ許可されます。基本的な型（ポインタや `int`など）は、自明に破壊可能な型の配列と同様に、自明に破壊可能です。`constexpr`でマークされた変数は簡単に破壊できることに注意してください。
参照はオブジェクトではないため、破壊可能性の制約を受けないことに注意してください。ただし、動的初期化の制約は引き続き適用されます。特に、 `static T＆t = * newT;`の形式の関数ローカル静的参照が許可されます。
####初期化に関する決定
初期化はより複雑なトピックです。これは、クラスコンストラクターが実行されるかどうかだけでなく、初期化子の評価も考慮する必要があるためです。
最初のステートメント以外はすべて、初期化の順序が不確定であることがわかります。
私たちが探している概念は、C ++標準の形式言語では_定数初期化_と呼ばれます。これは、初期化式が定数式であることを意味し、オブジェクトがコンストラクター呼び出しによって初期化される場合、コンストラクターも `constexpr`として指定する必要があります。
一定の初期化は常に許可されます。静的ストレージ期間変数の一定の初期化は、 `constexpr`でマークするか、可能であれば[` ABSL_CONST_INIT`]（https://github.com/abseil/abseil- cpp / blob / 03c1513538584f4a04d666be5eb469e3979febba / absl / base / attributes.h#L540）属性。そのようにマークされていない非ローカル静的ストレージ期間変数は、動的初期化があると推定され、非常に注意深く確認する必要があります。
対照的に、次の初期化には問題があります。
非ローカル変数の動的初期化は推奨されておらず、一般的には禁止されています。ただし、プログラムのどの側面も、他のすべての初期化に関してこの初期化の順序に依存しない場合は、許可します。これらの制限の下では、初期化の順序によって目に見える違いは生じません。例えば：
静的ローカル変数の動的初期化が許可されます（そして一般的です）。
####一般的なパターン
*グローバル文字列：グローバルまたは静的文字列定数が必要な場合は、単純な文字配列、または文字列リテラルの最初の要素へのcharポインタの使用を検討してください。文字列リテラルにはすでに静的な保存期間があり、通常は十分です。 *マップ、セット、およびその他の動的コンテナ：検索するセットやルックアップテーブルなどの静的な固定コレクションが必要な場合、標準ライブラリの動的コンテナは静的変数として使用できません。 -ささいなデストラクタ。代わりに、単純な型の単純な配列、たとえばintの配列の配列（「intからintへのマップ」の場合）またはペアの配列（たとえば、 `int`と` const char * `のペア）を検討してください。 。小さなコレクションの場合、線形検索で十分です（メモリの局所性により効率的です）。標準操作には[absl / algorithm / container.h]（https://github.com/abseil/abseil-cpp/blob/master/absl/algorithm/container.h）の機能を使用することを検討してください。必要に応じて、コレクションを並べ替えられた順序で保持し、バイナリ検索アルゴリズムを使用します。標準ライブラリの動的コンテナが本当に必要な場合は、以下で説明するように、関数ローカル静的ポインタの使用を検討してください。 *スマートポインタ（ `unique_ptr`、` shared_ptr`）：スマートポインタは破棄中にクリーンアップを実行するため、禁止されています。ユースケースがこのセクションで説明されている他のパターンのいずれかに適合するかどうかを検討してください。簡単な解決策の1つは、動的に割り当てられたオブジェクトへのプレーンポインターを使用し、それを削除しないことです（最後の項目を参照）。 *カスタム型の静的変数：自分で定義する必要のある型の静的な定数データが​​必要な場合は、その型に簡単なデストラクタと `constexpr`コンストラクタを与えます。 *他のすべてが失敗した場合、オブジェクトを動的に作成し、関数ローカルの静的ポインターまたは参照を使用してオブジェクトを削除することはできません（例： `static const auto＆impl = * new T（args ...）;`）。
### thread_local変数
関数内で宣言されていない `thread_local`変数は、真のコンパイル時定数で初期化する必要があります。これは、[` ABSL_CONST_INIT`]（https://github.com/abseil/abseil- cpp/blob/master/absl/base/attributes.h）属性。スレッドローカルデータを定義する他の方法よりも `thread_local`を優先します。
C ++ 11以降、変数は `thread_local`指定子で宣言できます。
このような変数は実際にはオブジェクトのコレクションであるため、異なるスレッドがそれにアクセスすると、実際には異なるオブジェクトにアクセスします。`thread_local`変数は、多くの点で静的ストレージ期間変数によく似ています。たとえば、名前空間スコープ、関数内、または静的クラスメンバーとして宣言できますが、通常のクラスメンバーとしては宣言できません。
`thread_local`変数インスタンスは静的変数とほとんど同じように初期化されますが、プログラムの起動時に1回ではなく、スレッドごとに個別に初期化する必要がある点が異なります。つまり、関数内で宣言された `thread_local`変数は安全ですが、他の` thread_local`変数は、静的変数と同じ初期化順序の問題の影響を受けます（さらにそれ以上）。
`thread_local`変数インスタンスは、スレッドが終了すると破棄されるため、静的変数の破棄順序の問題はありません。
*スレッドローカルデータは本質的に競合から安全です（通常は1つのスレッドのみがアクセスできるため）。これにより、 `thread_local`は並行プログラミングに役立ちます。* `thread_local`は、スレッドローカルデータを作成するための唯一の標準サポートされた方法です。
* `thread_local`変数にアクセスすると、予測不可能で制御不可能な量の他のコードの実行がトリガーされる可能性があります。* `thread_local`変数は事実上グローバル変数であり、スレッドセーフの欠如以外にグローバル変数のすべての欠点があります。* `thread_local`変数によって消費されるメモリは、実行中のスレッドの数（最悪の場合）に比例します。これは、プログラムでは非常に大きくなる可能性があります。*通常のクラスメンバーを `thread_local`にすることはできません。* `thread_local`は、特定のコンパイラ組み込み関数ほど効率的でない場合があります。
関数内の `thread_local`変数には安全上の懸念がないため、制限なしで使用できます。関数スコープの `thread_local`を使用して、それを公開する関数または静的メソッドを定義することにより、クラススコープまたは名前空間スコープの` thread_local`をシミュレートできることに注意してください。
クラスまたは名前空間スコープの `thread_local`変数は、真のコンパイル時定数で初期化する必要があります（つまり、動的初期化があってはなりません）。これを強制するには、クラスまたは名前空間スコープの `thread_local`変数に[` ABSL_CONST_INIT`]（https://github.com/abseil/abseil- cpp / blob / master / absl / base / attributes.h）（または `constexpr`ですが、それはまれなはずです）：
`thread_local`は、スレッドローカルデータを定義するための他のメカニズムよりも優先されるべきです。
## クラス
クラスは、C ++のコードの基本単位です。当然、私たちはそれらを広く使用しています。このセクションでは、クラスを作成するときに従う必要のある主な注意事項と禁止事項を示します。
###コンストラクターで作業を行う
コンストラクターでの仮想メソッド呼び出しを回避し、エラーを通知できない場合に失敗する可能性のある初期化を回避します。
コンストラクターの本体で任意の初期化を実行することができます。
*クラスが初期化されているかどうかを心配する必要はありません。*コンストラクター呼び出しによって完全に初期化されるオブジェクトは `const`である可能性があり、標準のコンテナーまたはアルゴリズムで使用する方が簡単な場合もあります。
*作業が仮想関数を呼び出す場合、これらの呼び出しはサブクラスの実装にディスパッチされません。クラスを将来変更すると、クラスが現在サブクラス化されていない場合でも、この問題が静かに発生し、多くの混乱が生じる可能性があります。*プログラムをクラッシュさせる（常に適切であるとは限らない）か、例外を使用する（禁止されている）以外に、コンストラクターがエラーを通知する簡単な方法はありません。*作業が失敗した場合、初期化コードが失敗したオブジェクトが存在するため、呼び出しを忘れがちな `bool IsValid（）`状態チェックメカニズム（または同様のもの）を必要とする異常な状態である可能性があります。*コンストラクターのアドレスを取得することはできないため、コンストラクターで行われた作業を、たとえば別のスレッドに簡単に渡すことはできません。
コンストラクターは仮想関数を呼び出さないでください。コードに適切な場合は、プログラムを終了することが適切なエラー処理応答である可能性があります。それ以外の場合は、[TotW#42]（https://abseil.io/tips/42）で説明されているファクトリ関数または `Init（）`メソッドを検討してください。どのパブリックメソッドが呼び出されるかに影響を与える他の状態がないオブジェクトでは、 `Init（）`メソッドを使用しないでください（この形式の半構築オブジェクトは、正しく操作するのが特に困難です）。
###暗黙の変換
暗黙の変換を定義しないでください。変換演算子と単一引数のコンストラクターには、 `explicit`キーワードを使用します。
暗黙的な変換により、「double」パラメーターを受け取る関数に「int」引数を渡す場合など、別のタイプ（宛先タイプと呼ばれる）が予想される場合に、あるタイプ（ソースタイプと呼ばれる）のオブジェクトを使用できます。
言語によって定義された暗黙的な変換に加えて、ユーザーは、ソースまたは宛先タイプのクラス定義に適切なメンバーを追加することにより、独自の変換を定義できます。ソース型の暗黙的な変換は、宛先型にちなんで名付けられた型変換演算子（ `operator bool（）`など）によって定義されます。宛先タイプの暗黙的な変換は、ソースタイプを唯一の引数（またはデフォルト値のない唯一の引数）として取ることができるコンストラクターによって定義されます。
`explicit`キーワードは、コンストラクターまたは（C ++ 11以降）変換演算子に適用して、キャストなどの使用時に宛先タイプが明示的である場合にのみ使用できるようにすることができます。これは、暗黙的な変換だけでなく、C ++ 11のリスト初期化構文にも適用されます。
この種のコードは、技術的には暗黙的な変換ではありませんが、「明示的」に関する限り、言語はそれを1つとして扱います。
*暗黙的な変換は、明らかなときに型に明示的に名前を付ける必要をなくすことにより、型をより使いやすく表現力豊かにすることができます。*暗黙的な変換は、 `std :: string`と` const char * `の個別のオーバーロードの代わりに、` string_view`パラメータを持つ単一の関数を使用する場合など、オーバーロードのより簡単な代替手段になります。*リスト初期化構文は、オブジェクトを初期化するための簡潔で表現力豊かな方法です。
*暗黙的な変換により、宛先タイプがユーザーの期待と一致しない、またはユーザーが変換が行われることに気付かない場合に、タイプの不一致のバグを隠すことができます。 *暗黙的な変換は、実際にどのコードが呼び出されているかがわかりにくくなるため、特にオーバーロードが存在する場合に、コードが読みにくくなる可能性があります。 *単一の引数を取るコンストラクターは、意図されていない場合でも、誤って暗黙の型変換として使用される可能性があります。 *単一引数のコンストラクターが「明示的」とマークされていない場合、それが暗黙的な変換を定義することを意図しているかどうか、または作成者が単にマークするのを忘れたかどうかを判断する信頼できる方法はありません。 *暗黙的な変換は、特に双方向の暗黙的な変換がある場合に、呼び出しサイトのあいまいさを引き起こす可能性があります。これは、両方が暗黙的な変換を提供する2つの型があるか、暗黙的なコンストラクターと暗黙的な型変換演算子の両方を持つ単一の型が原因で発生する可能性があります。 *宛先タイプが暗黙的である場合、特にリストに要素が1つしかない場合、リストの初期化で同じ問題が発生する可能性があります。
型変換演算子、および単一の引数で呼び出すことができるコンストラクターは、クラス定義で「明示的」とマークする必要があります。例外として、コピーおよび移動コンストラクターは型変換を実行しないため、「明示的」であってはなりません。
暗黙的な変換は、互換性があるように設計されたタイプに対して必要かつ適切な場合があります。たとえば、2つのタイプのオブジェクトが、同じ基になる値の異なる表現である場合などです。その場合は、プロジェクトリードに連絡して、このルールの免除をリクエストしてください。
単一の引数で呼び出すことができないコンストラクターは、 `explicit`を省略できます。単一の `std :: initializer_list`パラメーターを受け取るコンストラクターも、コピーの初期化をサポートするために、` explicit`を省略する必要があります（例： `MyType m = {1、2};`）。
###コピー可能および移動可能なタイプ
クラスのパブリックAPIは、クラスがコピー可能か、移動専用か、コピー可能でも移動可能でもないかどうかを明確にする必要があります。これらの操作が明確で、タイプにとって意味がある場合は、コピーや移動をサポートしてください。
活字とは、一時的な活字から初期化して割り当てることができる活字です。
コピー可能なタイプとは、ソースの値が変更されないことを条件として、同じタイプの他のオブジェクトから初期化または割り当てることができるタイプです（したがって、定義上も移動可能です）。`std :: unique_ptr <int>`は、移動可能であるがコピー可能ではない型の例です（ソース `std :: unique_ptr <int>`の値は、宛先への割り当て中に変更する必要があるため）。`int`と` std :: string`は、コピー可能な可動型の例です。（ `int`の場合、移動操作とコピー操作は同じです。`std:: string`の場合、コピーよりも安価な移動操作が存在します。）
ユーザー定義型の場合、コピー動作はコピーコンストラクターとコピー割り当て演算子によって定義されます。移動動作は、存在する場合は移動コンストラクターと移動割り当て演算子によって定義され、存在しない場合はコピーコンストラクターとコピー割り当て演算子によって定義されます。
コピー/移動コンストラクターは、オブジェクトを値で渡す場合など、状況によってはコンパイラーによって暗黙的に呼び出される可能性があります。
コピー可能および移動可能なタイプのオブジェクトは、値によって受け渡しおよび返すことができるため、APIがより単純で、より安全で、より一般的になります。ポインタや参照でオブジェクトを渡す場合とは異なり、所有権、存続期間、可変性、および同様の問題について混乱するリスクはなく、コントラクトでそれらを指定する必要もありません。また、クライアントと実装の間の非ローカルな相互作用を防ぎ、コンパイラによる理解、維持、および最適化を容易にします。さらに、このようなオブジェクトは、ほとんどのコンテナなど、値による受け渡しを必要とする汎用APIで使用でき、型の構成などの柔軟性を高めることができます。
コピー/移動コンストラクターと代入演算子は、コンパイラーによって暗黙的またはデフォルトで生成できるため、通常、 `Clone（）`、 `CopyFrom（）`、 `Swap（）`などの代替手段よりも正しく定義する方が簡単です。`。それらは簡潔であり、すべてのデータメンバーがコピーされることを保証します。コピーと移動のコンストラクターは、ヒープの割り当てや個別の初期化と割り当ての手順を必要とせず、[コピーの省略]（http://en.cppreference.com/w）などの最適化の対象となるため、一般的に効率的です。/ cpp / language / copy_elision）。
移動操作により、右辺値オブジェクトからのリソースの暗黙的かつ効率的な転送が可能になります。これにより、場合によっては、よりわかりやすいコーディングスタイルが可能になります。
一部のタイプはコピー可能である必要はなく、そのようなタイプにコピー操作を提供すると、混乱したり、無意味になったり、まったく正しくなかったりする可能性があります。シングルトンオブジェクト（ `Registerer`）、特定のスコープに関連付けられたオブジェクト（` Cleanup`）、またはオブジェクトIDに密接に結合されたオブジェクト（ `Mutex`）を表すタイプは、意味のある形でコピーできません。多態的に使用される基本クラスタイプのコピー操作は、[オブジェクトのスライス]（https://en.wikipedia.org/wiki/Object_slicing）につながる可能性があるため、危険です。デフォルトまたは不注意に実装されたコピー操作は正しくない可能性があり、結果として生じるバグは混乱を招き、診断が困難になる可能性があります。
コピーコンストラクターは暗黙的に呼び出されるため、呼び出しを見逃しやすくなります。これは、参照渡しが従来型または必須である言語に慣れているプログラマーにとって混乱を引き起こす可能性があります。また、過度のコピーが発生し、パフォーマンスの問題が発生する可能性があります。
すべてのクラスのパブリックインターフェイスは、クラスがサポートするコピーおよび移動操作を明確にする必要があります。これは通常、宣言の「public」セクションで適切な操作を明示的に宣言および/または削除するという形をとる必要があります。
具体的には、コピー可能なクラスはコピー操作を明示的に宣言する必要があり、移動専用クラスは移動操作を明示的に宣言する必要があり、コピー不可能/移動可能なクラスはコピー操作を明示的に削除する必要があります。コピー可能なクラスは、効率的な移動をサポートするために移動操作を宣言することもできます。4つのコピー/移動操作すべてを明示的に宣言または削除することは許可されていますが、必須ではありません。コピーまたはムーブ代入演算子を指定する場合は、対応するコンストラクターも指定する必要があります。
これらの宣言/削除は、明らかな場合にのみ省略できます。
*構造体やインターフェイスのみの基本クラスのように、クラスに「プライベート」セクションがない場合、コピー可能性/移動可能性は、パブリックデータメンバーのコピー可能性/移動可能性によって決定できます。*基本クラスが明らかにコピー可能または移動可能でない場合、派生クラスも当然コピー可能ではありません。これらの操作を暗黙的に残すインターフェースのみの基本クラスは、具体的なサブクラスを明確にするのに十分ではありません。*コピーのコンストラクターまたは代入操作のいずれかを明示的に宣言または削除した場合、他のコピー操作は明確ではないため、宣言または削除する必要があることに注意してください。移動操作についても同様です。
カジュアルユーザーにとってコピー/移動の意味が不明確な場合、または予期しないコストが発生する場合は、タイプをコピー/移動できないようにする必要があります。コピー可能なタイプの移動操作は厳密にパフォーマンスの最適化であり、バグや複雑さの潜在的な原因となるため、対応するコピー操作よりも大幅に効率的でない限り、それらを定義することは避けてください。タイプがコピー操作を提供する場合、それらの操作のデフォルトの実装が正しくなるようにクラスを設計することをお勧めします。他のコードと同じように、デフォルトの操作の正確さを確認することを忘れないでください。
スライスのリスクがあるため、派生することを目的としたクラスにパブリック代入演算子またはコピー/移動コンストラクターを提供することは避けてください（そのようなメンバーを持つクラスから派生することは避けてください）。基本クラスをコピー可能にする必要がある場合は、パブリック仮想 `Clone（）`メソッドと、派生クラスがそれを実装するために使用できる保護されたコピーコンストラクターを提供します。
###構造体とクラス
データを運ぶパッシブオブジェクトにのみ `struct`を使用します。他のすべては `クラス`です。
`struct`キーワードと` class`キーワードは、C ++でもほぼ同じように動作します。各キーワードに独自のセマンティックな意味を追加するため、定義するデータ型に適切なキーワードを使用する必要があります。
`structs`は、データを運ぶパッシブオブジェクトに使用する必要があり、定数が関連付けられている場合があります。すべてのフィールドはパブリックである必要があります。これらのフィールドへの直接のユーザーアクセスはそれらの不変条件を壊す可能性があるため、構造体は異なるフィールド間の関係を暗示する不変条件を持ってはなりません。コンストラクタ、デストラクタ、およびヘルパーメソッドが存在する場合があります。ただし、これらのメソッドは不変条件を要求または強制してはなりません。
より多くの機能または不変条件が必要な場合は、 `class`がより適切です。疑わしい場合は、それを「クラス」にします。
STLとの一貫性を保つために、トレイト、テンプレートメタ関数、一部のファンクターなどのステートレス型には、 `class`の代わりに` struct`を使用できます。
構造体とクラスのメンバー変数には異なる命名規則があることに注意してください。
###構造体とペアおよびタプル
要素に意味のある名前を付けることができる場合は常に、ペアまたはタプルの代わりに `struct`を使用することをお勧めします。
ペアとタプルを使用すると、カスタムタイプを定義する必要がなくなり、コードを書くときの作業を節約できる可能性がありますが、コードを読むときは、ほとんどの場合、意味のあるフィールド名が `.first`、` .second`、または `stdよりもはるかに明確になります。：get <X> `。C ++ 14の `std :: get <Type>`の導入により、インデックスではなくタイプでタプル要素にアクセスできる場合（タイプが一意の場合）、これを部分的に軽減できる場合がありますが、フィールド名は通常、より明確で有益です。タイプ。
ペアとタプルは、ペアまたはタプルの要素に特定の意味がないジェネリックコードで適切な場合があります。既存のコードまたはAPIと相互運用するために、それらの使用も必要になる場合があります。
###継承
多くの場合、継承よりも構成の方が適切です。継承を使用する場合は、「パブリック」にします。
サブクラスが基本クラスから継承する場合、基本クラスが定義するすべてのデータと操作の定義が含まれます。「インターフェース継承」は、純粋な抽象基本クラス（状態または定義されたメソッドを持たないもの）からの継承です。他のすべての継承は「実装継承」です。
実装の継承は、既存の型を特殊化するため、基本クラスのコードを再利用することでコードサイズを削減します。継承はコンパイル時の宣言であるため、ユーザーとコンパイラーは操作を理解してエラーを検出できます。インターフェイスの継承を使用して、クラスが特定のAPIを公開するようにプログラムで強制できます。この場合も、クラスがAPIの必要なメソッドを定義していない場合、コンパイラはエラーを検出できます。
実装の継承では、サブクラスを実装するコードが基本クラスとサブクラスの間に分散しているため、実装を理解するのがより困難になる可能性があります。サブクラスは仮想ではない関数をオーバーライドできないため、サブクラスは実装を変更できません。
多重継承は、パフォーマンスのオーバーヘッドが高くなることが多く（実際、単一継承から複数継承へのパフォーマンスの低下は、通常のディスパッチから仮想ディスパッチへのパフォーマンスの低下よりも大きくなることが多い）、「ダイヤモンド」につながるリスクがあるため、特に問題があります。「あいまいさ、混乱、および完全なバグが発生しやすい継承パターン。
すべての継承は `public`である必要があります。プライベート継承を行う場合は、代わりに基本クラスのインスタンスをメンバーとして含める必要があります。
実装の継承を使いすぎないでください。多くの場合、構成の方が適切です。継承の使用を「is-a」の場合に制限してみてください。「Bar」が「Foo」の一種であると合理的に言える場合は、「Bar」は「Foo」をサブクラス化します。
`protected`の使用を、サブクラスからアクセスする必要がある可能性のあるメンバー関数に制限します。データメンバーはプライベートである必要があることに注意してください。
仮想関数または仮想デストラクタのオーバーライドに、「オーバーライド」または（頻度は少ないが）「最終」指定子のいずれか1つだけで明示的に注釈を付けます。オーバーライドを宣言するときに `virtual`を使用しないでください。理論的根拠：基本クラスの仮想関数のオーバーライドではない「override」または「final」とマークされた関数またはデストラクタはコンパイルされず、これは一般的なエラーをキャッチするのに役立ちます。指定子はドキュメントとして機能します。指定子が存在しない場合、リーダーは問題のクラスのすべての祖先をチェックして、関数またはデストラクタが仮想であるかどうかを判断する必要があります。
多重継承は許可されていますが、複数の_implementation_継承は強くお勧めしません。
###演算子のオーバーロード
オペレーターを慎重に過負荷にします。ユーザー定義のリテラルは使用しないでください。
C ++では、パラメーターの1つが次の場合に限り、ユーザーコードで[組み込み演算子のオーバーロードバージョンを宣言する]（http://en.cppreference.com/w/cpp/language/operators） `operator`キーワードを使用できます。ユーザー定義の型。`operator`キーワードを使用すると、ユーザーコードで` operator "" `を使用して新しい種類のリテラルを定義したり、` operator bool（） `などの型変換関数を定義したりすることもできます。
演算子のオーバーロードは、ユーザー定義型が組み込み型と同じように動作できるようにすることで、コードをより簡潔で直感的にすることができます。オーバーロードされた演算子は、特定の操作（たとえば、 `==`、 `<`、 `=`、および `<<`）の慣用的な名前であり、これらの規則に従うと、ユーザー定義の型が読みやすくなり、相互運用できるようになります。それらの名前を期待するライブラリで。
ユーザー定義リテラルは、ユーザー定義タイプのオブジェクトを作成するための非常に簡潔な表記法です。
*正しく、一貫性があり、驚くことのない一連のオペレーターの過負荷を提供するには、ある程度の注意が必要です。そうしないと、混乱やバグが発生する可能性があります。 *演算子を使いすぎると、特にオーバーロードされた演算子のセマンティクスが規則に従わない場合、コードが難読化される可能性があります。 *関数のオーバーロードの危険性は、オペレーターのオーバーロードにも同じように当てはまります。 *オペレーターの過負荷は、高価な操作は安価な組み込み操作であると直感的に誤解する可能性があります。 *オーバーロードされた演算子の呼び出しサイトを見つけるには、grepなどではなく、C ++構文を認識する検索ツールが必要になる場合があります。 *オーバーロードされた演算子の引数タイプを間違えると、コンパイラエラーではなく別のオーバーロードが発生する可能性があります。たとえば、 `foo <bar`は1つのことを実行しますが、`＆foo <＆bar`はまったく異なることを実行します。 *特定のオペレーターの過負荷は本質的に危険です。単項 `＆`をオーバーロードすると、オーバーロード宣言が表示されるかどうかに応じて、同じコードの意味が異なる可能性があります。 `&&`、 `||`、および `、`（コンマ）のオーバーロードは、組み込み演算子の評価順序セマンティクスと一致できません。 *演算子はクラスの外部で定義されることが多いため、異なるファイルが同じ演算子の異なる定義を導入するリスクがあります。両方の定義が同じバイナリにリンクされている場合、これにより未定義の動作が発生し、微妙な実行時のバグとして現れる可能性があります。 *ユーザー定義リテラル（UDL）を使用すると、 `std :: string_view（" Hello World "）`の省略形としての `" Hello World "sv`など、経験豊富なC ++プログラマーでもなじみのない新しい構文形式を作成できます。簡潔ではありませんが、既存の表記法はより明確です。 *名前空間で修飾できないため、UDLを使用するには、using-directives（禁止）またはusing-declarations（インポートされた名前がによって公開されるインターフェイスの一部である場合を除き、ヘッダーファイルで禁止）のいずれかを使用する必要があります。問題のヘッダーファイル）。ヘッダーファイルはUDLサフィックスを回避する必要があることを考えると、ヘッダーファイルとソースファイルの間でリテラルの規則が異なることは避けたいと考えています。
オーバーロードされた演算子は、その意味が明白で、驚くことではなく、対応する組み込み演算子と一致している場合にのみ定義してください。たとえば、 `|`をビット単位または論理として、またはシェルスタイルのパイプとしてではなく使用します。
独自のタイプでのみ演算子を定義します。より正確には、操作するタイプと同じヘッダー、.ccファイル、および名前空間でそれらを定義します。これにより、タイプがどこにあっても演算子を使用できるため、複数の定義のリスクが最小限に抑えられます。可能であれば、演算子をテンプレートとして定義することは避けてください。可能なテンプレート引数については、この規則を満たす必要があるためです。演算子を定義する場合は、意味のある関連演算子も定義し、それらが一貫して定義されていることを確認してください。たとえば、 `<`をオーバーロードする場合は、すべての比較演算子をオーバーロードし、 `<`と `>`が同じ引数に対してtrueを返さないようにします。
非変更二項演算子を非メンバー関数として定義することをお勧めします。二項演算子がクラスメンバーとして定義されている場合、暗黙の変換は右側の引数に適用されますが、左側の引数には適用されません。`a <b`がコンパイルされても、` b <a`がコンパイルされない場合、ユーザーを混乱させます。
演算子のオーバーロードの定義を避けるために邪魔にならないでください。たとえば、 `Equals（）`、 `CopyFrom（）`、および `PrintTo（）`ではなく、 `==`、 `=`、および `<<`を定義することをお勧めします。逆に、他のライブラリが演算子のオーバーロードを予期しているという理由だけで、演算子のオーバーロードを定義しないでください。たとえば、型に自然な順序がないが、それを `std :: set`に格納したい場合は、` <`をオーバーロードするのではなく、カスタムコンパレータを使用します。
`&&`、 `||`、 `、`（コンマ）、または単項 `＆`をオーバーロードしないでください。`operator" "`をオーバーロードしないでください。つまり、ユーザー定義のリテラルを導入しないでください。他の人（標準ライブラリを含む）が提供するそのようなリテラルは使用しないでください。
型変換演算子については、暗黙的な変換のセクションで説明しています。`=`演算子については、コピーコンストラクターのセクションで説明しています。ストリームで使用するための `<<`のオーバーロードについては、ストリームのセクションで説明しています。演算子のオーバーロードにも適用される関数のオーバーロードに関する規則も参照してください。
### アクセス制御
クラスのデータメンバーを定数でない限り、「プライベート」にします。これにより、不変条件についての推論が簡単になりますが、必要に応じてアクセサ（通常は「const」）の形で簡単な定型文が使用されます。
技術的な理由から、[Google Test]（https://github.com/google/googletest））を使用する場合、.ccファイルで定義されたテストフィクスチャクラスのデータメンバーを「保護」することができます。テストフィクスチャクラスが、たとえば.hファイルで使用されている.ccファイルの外部で定義されている場合は、データメンバーを「プライベート」にします。
###宣言順序
同様の宣言をグループ化し、公開部分を早期に配置します。
クラス定義は通常、「public：」セクションで始まり、「protected：」、「private：」の順になります。空になるセクションは省略してください。
各セクション内で、同様の種類の宣言をグループ化することを好み、次の順序を好みます：タイプ（ `typedef`、` using`、ネストされた構造体とクラスを含む）、定数、ファクトリ関数、コンストラクタと代入演算子、デストラクタ、その他すべてメソッド、データメンバー。
大きなメソッド定義をクラス定義にインラインで配置しないでください。通常、インラインで定義できるのは、些細な、またはパフォーマンスが重要で、非常に短いメソッドのみです。詳細については、インライン関数を参照してください。
## 関数
###入力と出力
C ++関数の出力は、当然、戻り値を介して提供され、場合によっては出力パラメーター（または入出力パラメーター）を介して提供されます。
出力パラメーターよりも戻り値を使用することをお勧めします。これらは読みやすさを向上させ、多くの場合、同じかそれ以上のパフォーマンスを提供します。
値で返すか、それができない場合は参照で返すことをお勧めします。nullにならない限り、ポインタを返すことは避けてください。
パラメータは、関数への入力、関数からの出力、またはその両方です。入力パラメーターは通常、値または `const`参照である必要がありますが、オプションではない出力および入力/出力パラメーターは通常、参照である必要があります（nullにすることはできません）。一般に、 `absl :: optional`を使用してオプションの値による入力を表し、オプション以外のフォームが参照を使用する場合は` const`ポインターを使用します。オプションの出力を表すには、非 `const`ポインタを使用します。
`const`参照パラメーターは一時的なものにバインドされるため、呼び出しよりも長く存続するために` const`参照パラメーターを必要とする関数を定義することは避けてください。代わりに、ライフタイム要件を削除する方法を見つけるか（たとえば、パラメーターをコピーすることによって）、または `const`ポインターを渡して、ライフタイム要件とnull以外の要件を文書化します。
関数パラメーターを注文するときは、すべての入力専用パラメーターを出力パラメーターの前に置きます。特に、新しいパラメーターがあるという理由だけで、関数の最後に新しいパラメーターを追加しないでください。出力パラメータの前に新しい入力専用パラメータを配置します。これは厳格なルールではありません。入力と出力の両方であるパラメーターは水を濁し、いつものように、関連する関数との一貫性により、ルールを曲げる必要がある場合があります。可変個引数関数でも、異常なパラメーターの順序が必要になる場合があります。
###短い関数を書く
小さくて焦点を絞った機能を好む。
長い関数が適切な場合があることを認識しているため、関数の長さに厳しい制限はありません。関数が約40行を超える場合は、プログラムの構造を損なうことなく分割できるかどうかを検討してください。
長い関数が完全に機能するようになったとしても、数か月以内に誰かがそれを変更すると、新しい動作が追加される可能性があります。これにより、見つけるのが難しいバグが発生する可能性があります。関数を短くシンプルに保つことで、他の人がコードを読んだり変更したりしやすくなります。小さな関数もテストが簡単です。
一部のコードを操作すると、長くて複雑な関数が見つかる可能性があります。既存のコードを変更することを恐れないでください。そのような関数の操作が難しい場合、エラーのデバッグが難しい場合、またはその一部をいくつかの異なるコンテキストで使用したい場合は、関数をより小さなものに分割することを検討してください。そしてより扱いやすい部分。
###関数のオーバーロード
オーバーロードされた関数（コンストラクターを含む）は、呼び出しサイトを見ている読者が、どのオーバーロードが呼び出されているかを最初に正確に把握しなくても、何が起こっているのかをよく理解できる場合にのみ使用してください。
`const std :: string＆`をとる関数を書いて、 `const char *`をとる別の関数でオーバーロードすることができます。ただし、この場合は、代わりにstd :: string_viewを検討してください。
オーバーロードは、同じ名前の関数が異なる引数を取ることを可能にすることにより、コードをより直感的にすることができます。テンプレート化されたコードに必要な場合があり、訪問者にとって便利な場合があります。
constまたはref修飾に基づくオーバーロードは、ユーティリティコードをより使いやすく、より効率的に、またはその両方にすることができます。（詳細については、[TotW 148]（http://abseil.io/tips/148）を参照してください。）
関数が引数の型だけでオーバーロードされている場合、読者は何が起こっているのかを知るためにC ++の複雑なマッチングルールを理解する必要があるかもしれません。また、派生クラスが関数のバリアントの一部のみをオーバーライドする場合、多くの人々は継承のセマンティクスに混乱します。
バリアント間にセマンティックの違いがない場合は、関数をオーバーロードできます。これらのオーバーロードは、タイプ、修飾子、または引数数が異なる場合があります。ただし、そのような呼び出しの読者は、オーバーロードセットのどのメンバーが選択されているかを知る必要はなく、セットの**何か**が呼び出されているだけです。ヘッダーに1つのコメントを付けてオーバーロードセットのすべてのエントリを文書化できる場合、それは適切に設計されたオーバーロードセットであることを示す良い兆候です。
###デフォルトの引数
デフォルトが常に同じ値を持つことが保証されている場合、非仮想関数ではデフォルトの引数が許可されます。関数のオーバーロードと同じ制限に従い、デフォルトの引数で得られる可読性が以下の欠点を上回らない場合は、オーバーロードされた関数を優先します。
多くの場合、デフォルト値を使用する関数がありますが、デフォルトをオーバーライドしたい場合もあります。デフォルトのパラメーターを使用すると、まれな例外に対して多くの関数を定義しなくても、これを簡単に行うことができます。関数のオーバーロードと比較して、デフォルトの引数の構文はわかりやすく、定型文が少なく、「必須」引数と「オプション」引数の区別が明確になっています。
デフォルトの引数は、オーバーロードされた関数のセマンティクスを実現する別の方法であるため、関数をオーバーロードしないすべての理由が当てはまります。
仮想関数呼び出しの引数のデフォルトは、ターゲットオブジェクトの静的タイプによって決定され、特定の関数のすべてのオーバーライドが同じデフォルトを宣言するという保証はありません。
デフォルトのパラメータは各呼び出しサイトで再評価されるため、生成されたコードが肥大化する可能性があります。読者は、呼び出しごとに変化するのではなく、デフォルトの値が宣言で固定されることを期待する場合もあります。
関数のシグネチャが呼び出しのシグネチャと一致しないことが多いため、デフォルトの引数が存在する場合、関数ポインタは混乱を招きます。関数のオーバーロードを追加すると、これらの問題を回避できます。
デフォルト引数は、仮想関数で禁止されており、正しく機能しない場合や、指定されたデフォルトがいつ評価されたかによっては同じ値に評価されない場合があります。（たとえば、 `void f（int n = counter ++）;`とは書かないでください。）
他のいくつかのケースでは、デフォルトの引数は、上記の欠点を克服するのに十分な関数宣言の可読性を向上させることができるので、許可されます。疑わしい場合は、オーバーロードを使用してください。
###末尾の戻り値の型の構文
末尾の戻り値の型は、通常の構文（先頭の戻り値の型）を使用することが実用的でないか、読みにくい場合にのみ使用してください。
C ++では、2つの異なる形式の関数宣言が可能です。古い形式では、戻り値の型は関数名の前に表示されます。例えば：
C ++ 11で導入された新しい形式では、関数名の前に `auto`キーワードを使用し、引数リストの後に末尾の戻り値の型を使用します。たとえば、上記の宣言は同等に書くことができます：
末尾の戻り値の型は関数のスコープ内にあります。これは、 `int`のような単純な場合には違いはありませんが、クラススコープで宣言された型や、関数パラメーターの観点から記述された型など、より複雑な場合には重要です。
末尾の戻り値の型は、ラムダ式の戻り値の型を明示的に指定する唯一の方法です。コンパイラがラムダの戻り値の型を推測できる場合もありますが、すべての場合ではありません。コンパイラーがそれを自動的に推測できる場合でも、それを明示的に指定する方が読者にとってより明確な場合があります。
関数のパラメータリストがすでに表示された後で戻り値の型を指定する方が簡単で読みやすい場合があります。これは、戻り値の型がテンプレートパラメータに依存する場合に特に当てはまります。例えば：
対
末尾の戻り値の型の構文は比較的新しく、CやJavaなどのC ++のような言語には類似していないため、一部の読者はなじみがないと感じるかもしれません。
既存のコードベースには、新しい構文を使用するように変更されない膨大な数の関数宣言があるため、現実的な選択は、古い構文のみを使用するか、2つを組み合わせて使用することです。単一のバージョンを使用すると、スタイルの均一性が向上します。
ほとんどの場合、戻り値の型が関数名の前にある古いスタイルの関数宣言を引き続き使用します。新しいtrailing-return-type形式は、必要な場合（ラムダなど）、または関数のパラメーターリストの後に型を配置することで、はるかに読みやすい方法で型を記述できる場合にのみ使用してください。後者の場合はまれです。これはほとんどの場合、かなり複雑なテンプレートコードの問題であり、ほとんどの場合推奨されません。
## Google固有の魔法
C ++コードをより堅牢にするために使用するさまざまなトリックやユーティリティがあり、他の場所で見られるものとは異なる可能性のあるC ++のさまざまな使用方法があります。
###所有権とスマートポインタ
動的に割り当てられたオブジェクトには、単一の固定所有者がいることをお勧めします。スマートポインタを使用して所有権を譲渡することをお勧めします。
「所有権」は、動的に割り当てられたメモリ（およびその他のリソース）を管理するための簿記手法です。動的に割り当てられたオブジェクトの所有者は、不要になったときにオブジェクトが削除されるようにする責任があるオブジェクトまたは関数です。所有権を共有できる場合もあります。その場合、通常、最後の所有者が所有権を削除する責任があります。所有権が共有されていない場合でも、あるコードから別のコードに所有権を譲渡できます。
「スマート」ポインタは、たとえば、 `*`および `->`演算子をオーバーロードすることによってポインタのように機能するクラスです。一部のスマートポインタータイプを使用して、所有権の簿記を自動化し、これらの責任を確実に果たすことができます。[`std :: unique_ptr`]（http://en.cppreference.com/w/cpp/memory/unique_ptr）は、C ++ 11で導入されたスマートポインター型であり、動的に割り当てられたオブジェクトの排他的所有権を表します。`std :: unique_ptr`がスコープ外になると、オブジェクトは削除されます。コピーすることはできませんが、所有権の譲渡を表すために_移動_することができます。[`std :: shared_ptr`]（http://en.cppreference.com/w/cpp/memory/shared_ptr）は、動的に割り当てられたオブジェクトの共有所有権を表すスマートポインター型です。`std :: shared_ptr`をコピーできます。オブジェクトの所有権はすべてのコピー間で共有され、最後の `std :: shared_ptr`が破棄されるとオブジェクトは削除されます。
*何らかの所有権ロジックがないと、動的に割り当てられたメモリを管理することは事実上不可能です。*オブジェクトの所有権を譲渡する方が、コピーするよりも安価な場合があります（コピーが可能な場合でも）。*所有権の譲渡は、2人のユーザー間でオブジェクトの存続期間を調整する必要性を減らすため、ポインターまたは参照を「借用」するよりも簡単です。*スマートポインターは、所有権ロジックを明示的、自己文書化、および明確にすることにより、読みやすさを向上させることができます。*スマートポインターは、手動の所有権の簿記を排除し、コードを簡素化し、大きなクラスのエラーを排除することができます。* constオブジェクトの場合、共有所有権は、ディープコピーのシンプルで効率的な代替手段になります。
*所有権は、ポインターを介して表され、転送される必要があります（スマートかプレーンかに関係なく）。特にAPIでは、ポインターセマンティクスは値セマンティクスよりも複雑です。所有権だけでなく、エイリアシング、存続期間、可変性などの問題についても心配する必要があります。 *値のセマンティクスのパフォーマンスコストは過大評価されることが多いため、所有権の譲渡によるパフォーマンス上の利点は、読みやすさと複雑さのコストを正当化しない可能性があります。 *所有権を譲渡するAPIは、クライアントを単一のメモリ管理モデルに強制します。 *スマートポインターを使用するコードは、リソースの解放が行われる場所についてあまり明確ではありません。 * `std :: unique_ptr`は、C ++ 11の移動セマンティクスを使用して所有権の譲渡を表します。これは比較的新しく、一部のプログラマーを混乱させる可能性があります。 *共有所有権は、慎重な所有権設計の魅力的な代替手段となり、システムの設計を難読化する可能性があります。 *共有所有権では、実行時に明示的な簿記が必要であり、コストがかかる可能性があります。 *場合によっては（循環参照など）、所有権が共有されているオブジェクトが削除されない場合があります。 *スマートポインタは、プレーンポインタの完全な代替ではありません。
動的割り当てが必要な場合は、それを割り当てたコードの所有権を維持することをお勧めします。他のコードがオブジェクトにアクセスする必要がある場合は、オブジェクトにコピーを渡すか、所有権を譲渡せずにポインターまたは参照を渡すことを検討してください。所有権の譲渡を明示的にするには、 `std :: unique_ptr`を使用することをお勧めします。例えば：
非常に正当な理由がない限り、共有所有権を使用するようにコードを設計しないでください。そのような理由の1つは、コストのかかるコピー操作を回避することですが、パフォーマンス上の利点が大きく、基になるオブジェクトが不変である場合にのみこれを行う必要があります（つまり、 `std :: shared_ptr <const Foo>`）。共有所有権を使用する場合は、 `std :: shared_ptr`を使用することをお勧めします。
`std :: auto_ptr`は絶対に使用しないでください。代わりに、 `std :: unique_ptr`を使用してください。
### cpplint
`cpplint.py`を使用してスタイルエラーを検出します。
`cpplint.py`は、ソースファイルを読み取り、多くのスタイルエラーを識別するツールです。完璧ではなく、誤検知と誤検知の両方がありますが、それでも貴重なツールです。
一部のプロジェクトには、プロジェクトツールから `cpplint.py`を実行する方法についての説明があります。貢献しているプロジェクトがそうでない場合は、[`cpplint.py`]（https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py）を個別にダウンロードできます。
##その他のC ++機能
###右辺値参照
右辺値参照は、以下にリストされている特定の特別な場合にのみ使用してください。
右辺値参照は、一時オブジェクトにのみバインドできる参照の一種です。構文は、従来の参照構文に似ています。たとえば、 `void f（std :: string && s）;`は、引数がstd :: stringへの右辺値参照である関数を宣言します。
トークン '&&'が関数パラメーターの非修飾テンプレート引数に適用されると、特別なテンプレート引数の推論規則が適用されます。このような参照は、転送参照と呼ばれます。
*移動コンストラクター（クラス型への右辺値参照を取得するコンストラクター）を定義すると、値をコピーする代わりに移動することができます。たとえば、 `v1`が` std :: vector <std :: string> `の場合、` auto v2（std :: move（v1）） `は、大きなものをコピーするのではなく、単純なポインタ操作を行うだけです。データ量。多くの場合、これによりパフォーマンスが大幅に向上する可能性があります。 *右辺値参照を使用すると、移動可能であるがコピー可能ではない型を実装できます。これは、コピーの適切な定義がないが、関数の引数として渡したり、コンテナーに入れたりする必要がある型に役立ちます。* `std :: move`は、` std :: unique_ptr`などのいくつかの標準ライブラリタイプを効果的に使用するために必要です。 *右辺値参照トークンを使用する参照の転送により、引数を別の関数に転送し、引数が一時オブジェクトやconstであるかどうかに関係なく機能する汎用関数ラッパーを記述できます。これは「完全転送」と呼ばれます。
*右辺値の参照はまだ広く理解されていません。参照の折りたたみや参照を転送するための特別な控除ルールなどのルールは、ややあいまいです。*右辺値参照はしばしば誤用されます。右辺値参照の使用は、関数呼び出し後に引数が有効な指定された状態になると予想されるシグニチャ、または移動操作が実行されないシグニチャでは直感に反します。
次の場合を除いて、右辺値参照を使用しないでください（または、メソッドに `&&`修飾子を適用してください）。
*これらを使用して、移動コンストラクターと移動代入演算子を定義できます（コピー可能タイプと移動可能タイプで説明されています）。 *これらを使用して、 `* this`を論理的に「消費」し、使用できない状態または空の状態のままにする` && `修飾メソッドを定義できます。これは、メソッド修飾子（関数シグニチャーの閉じ括弧の後に来る）にのみ適用されることに注意してください。通常の関数パラメーターを「消費」したい場合は、値で渡すことをお勧めします。 *完全な転送をサポートするために、転送参照を `[std :: forward]（http://en.cppreference.com/w/cpp/utility/forward）`と組み合わせて使用​​できます。 *これらを使用して、一方が「Foo &&」を取得し、もう一方が「const Foo＆」を取得するなど、オーバーロードのペアを定義できます。通常、推奨される解決策は値を渡すことですが、関数のオーバーロードされたペアはパフォーマンスが向上する場合があり、さまざまなタイプをサポートする必要があるジェネリックコードで必要になる場合があります。いつものように：パフォーマンスのためにもっと複雑なコードを書いている場合は、それが実際に役立つという証拠があることを確認してください。
###友達
理由の範囲内で、 `friend`クラスと関数の使用を許可します。
読者がクラスのプライベートメンバーの使用法を見つけるために別のファイルを調べる必要がないように、通常、フレンドは同じファイルで定義する必要があります。`friend`の一般的な使用法は、` FooBuilder`クラスを `Foo`のフレンドにして、この状態を世界に公開することなく、` Foo`の内部状態を正しく構築できるようにすることです。場合によっては、ユニットテストクラスをテストするクラスの友達にすることが役立つ場合があります。
友達はクラスのカプセル化境界を拡張しますが、壊すことはありません。他の1つのクラスのみにアクセスを許可する場合は、メンバーを公開するよりも優れている場合があります。ただし、ほとんどのクラスは、パブリックメンバーのみを介して他のクラスと対話する必要があります。
###例外
C ++例外は使用しません。
*例外により、アプリケーションの上位レベルで、エラーコードを不明瞭にし、エラーが発生しやすい簿記を作成することなく、深くネストされた関数で「発生しない」障害を処理する方法を決定できます。
*例外は、他のほとんどの現代言語で使用されています。それらをC ++で使用すると、Python、Java、および他の人が精通しているC ++との整合性が高まります。
*一部のサードパーティC ++ライブラリは例外を使用し、それらを内部でオフにすると、それらのライブラリとの統合が困難になります。*例外は、コンストラクターが失敗する唯一の方法です。これはファクトリ関数または `Init（）`メソッドでシミュレートできますが、これらにはそれぞれヒープ割り当てまたは新しい「無効な」状態が必要です。*例外は、フレームワークのテストで非常に便利です。
*既存の関数に `throw`ステートメントを追加するときは、その推移的な呼び出し元をすべて調べる必要があります。少なくとも基本的な例外の安全性を保証する必要があります。または、例外をキャッチして、結果としてプログラムが終了することに満足してはなりません。たとえば、 `f（）`が `g（）`を呼び出して `h（）`を呼び出し、 `h`が` f`がキャッチする例外をスローする場合、 `g`は注意する必要があります。そうしないと、正しくクリーンアップされない可能性があります。 *より一般的には、例外により、コードを調べてプログラムの制御フローを評価することが困難になります。関数が予期しない場所に戻る場合があります。これにより、保守性とデバッグが困難になります。例外を使用する方法と場所に関するいくつかのルールを使用してこのコストを最小限に抑えることができますが、開発者が知って理解する必要があるより多くのコストがかかります。 *例外安全性には、RAIIとさまざまなコーディング手法の両方が必要です。正しい例外安全コードを簡単に作成するには、多くのサポート機構が必要です。さらに、読者がコールグラフ全体を理解する必要がないように、例外安全コードは、永続状態に書き込むロジックを「コミット」フェーズに分離する必要があります。これには利点とコストの両方があります（おそらく、コミットを分離するためにコードを難読化する必要がある場合）。例外を許可すると、その価値がない場合でも、常にそれらのコストを支払う必要があります。 *例外をオンにすると、生成される各バイナリにデータが追加され、コンパイル時間が長くなり（おそらくわずかに）、アドレス空間の負荷が高くなる可能性があります。 *例外が利用できるようになると、開発者は、例外が適切でない場合は例外をスローするか、安全でない場合は例外から回復するように促される場合があります。たとえば、無効なユーザー入力によって例外がスローされることはありません。これらの制限を文書化するには、スタイルガイドをさらに長くする必要があります。
表面的には、特に新しいプロジェクトでは、例外を使用することの利点がコストを上回ります。ただし、既存のコードの場合、例外の導入はすべての依存コードに影響を及ぼします。例外が新しいプロジェクトを超えて伝播される可能性がある場合、新しいプロジェクトを既存の例外のないコードに統合することも問題になります。Googleの既存のC ++コードのほとんどは例外を処理する準備ができていないため、例外を生成する新しいコードを採用することは比較的困難です。
Googleの既存のコードは例外耐性がないことを考えると、例外を使用するコストは、新しいプロジェクトのコストよりもいくらか高くなります。変換プロセスは遅く、エラーが発生しやすくなります。エラーコードやアサーションなど、例外に代わる利用可能な代替手段が大きな負担になるとは考えていません。
例外の使用に対する私たちのアドバイスは、哲学的または道徳的な理由ではなく、実際的な理由に基づいています。Googleでオープンソースプロジェクトを使用したいのですが、それらのプロジェクトで例外を使用するのは難しいため、Googleオープンソースプロジェクトでも例外を回避するようアドバイスする必要があります。最初からやり直す必要があるとしたら、状況はおそらく異なるでしょう。
この禁止事項は、 `std :: exception_ptr`や` std :: nested_exception`などのC ++ 11で追加された例外処理関連機能にも適用されます。
Windowsコードでは、このルールには例外があります（しゃれは意図されていません）。
### `noexcept`
有用で正しい場合は、 `noexcept`を指定します。
`noexcept`指定子は、関数が例外をスローするかどうかを指定するために使用されます。`noexcept`とマークされた関数から例外がエスケープされると、プログラムは` std :: terminate`を介してクラッシュします。
`noexcept`演算子は、式が例外をスローしないように宣言されている場合にtrueを返すコンパイル時チェックを実行します。
*移動コンストラクターを `noexcept`として指定すると、パフォーマンスが向上する場合があります。たとえば、Tの移動コンストラクターが` noexcept`の場合、オブジェクトをコピーするのではなく、 `std :: vector <T> :: reset（）`が移動します。*関数に `noexcept`を指定すると、例外が有効になっている環境でコンパイラの最適化をトリガーできます。たとえば、` noexcept`指定子が原因で例外がスローされないことがわかっている場合、コンパイラはスタック巻き戻し用の追加コードを生成する必要はありません。。
*このガイドに従って例外が無効になっているプロジェクトでは、 `noexcept`指定子が正しいことを確認するのは難しく、正確さが何を意味するのかを定義するのも困難です。* `noexcept`を元に戻すのは、不可能ではないにしても難しいです。これは、呼び出し元が信頼している可能性があるという保証が、検出が難しい方法で排除されるためです。
関数の意図されたセマンティクスを正確に反映している場合、つまり、関数本体内から何らかの理由で例外がスローされた場合、致命的なエラーを表す場合、パフォーマンスに役立つ場合は「noexcept」を使用できます。移動コンストラクターの `noexcept`には、パフォーマンス上の有意義な利点があると想定できます。他の関数で `noexcept`を指定することでパフォーマンスに大きなメリットがあると思われる場合は、プロジェクトリーダーと話し合ってください。
例外が完全に無効になっている場合（つまり、ほとんどのGoogle C ++環境）は、無条件の `noexcept`を優先します。それ以外の場合は、関数がスローする可能性があるいくつかの場合にのみfalseを評価する方法で、単純な条件で条件付きの `noexcept`指定子を使用します。テストには、関連する操作がスローする可能性があるかどうか（たとえば、移動構築オブジェクトの場合は `std :: is_nothrow_move_constructible`）、または割り当てがスローできるかどうか（たとえば、標準のデフォルト割り当ての場合は` absl :: default_allocator_is_nothrow`）の型特性チェックが含まれる場合があります。多くの場合、例外の唯一の考えられる原因は割り当ての失敗であり（割り当ての失敗以外の理由で移動コンストラクターがスローされるべきではないと考えています）、メモリの枯渇を例外的な状態ではなく致命的なエラーとして扱うことが適切なアプリケーションが多数あります。プログラムが回復を試みる必要があること。他の潜在的な障害の場合でも、考えられるすべての例外スローシナリオをサポートするよりもインターフェイスの単純さを優先する必要があります。たとえば、ハッシュ関数がスローできるかどうかに依存する複雑な `noexcept`句を記述する代わりに、コンポーネントがハッシュをサポートしていないことを文書化するだけです。関数をスローし、無条件に `noexcept`にします。
###実行時型情報（RTTI）
実行時型情報（RTTI）の使用は避けてください。
RTTIを使用すると、プログラマーは実行時にオブジェクトのC ++クラスを照会できます。これは、 `typeid`または` dynamic_cast`を使用して行われます。
RTTIの標準的な代替手段（以下で説明）では、問題のクラス階層を変更または再設計する必要があります。特に広く使用されているコードや成熟したコードでは、このような変更が実行不可能または望ましくない場合があります。
RTTIは、一部の単体テストで役立ちます。たとえば、新しく作成されたオブジェクトが予期された動的型を持っていることをテストで確認する必要があるファクトリクラスのテストで役立ちます。また、オブジェクトとそのモックの間の関係を管理するのにも役立ちます。
RTTIは、複数の抽象オブジェクトを検討するときに役立ちます。検討する
実行時にオブジェクトのタイプを照会することは、設計上の問題を意味することがよくあります。実行時にオブジェクトのタイプを知る必要があることは、多くの場合、クラス階層の設計に欠陥があることを示しています。
RTTIを無秩序に使用すると、コードの保守が困難になります。これにより、タイプベースのデシジョンツリーまたはswitchステートメントがコード全体に散在する可能性があります。これらはすべて、さらに変更を加えるときに調べる必要があります。
RTTIは正当な用途がありますが、悪用される傾向があるため、使用する際には注意が必要です。ユニットテストでは自由に使用できますが、他のコードでは可能な限り避けてください。特に、新しいコードでRTTIを使用する前によく考えてください。オブジェクトのクラスに基づいて異なる動作をするコードを作成する必要がある場合は、タイプをクエリする代わりに次のいずれかを検討してください。
*仮想メソッドは、特定のサブクラスタイプに応じて異なるコードパスを実行するための推奨される方法です。これにより、作業がオブジェクト自体に配置されます。*作品がオブジェクトの外部に属し、代わりに一部の処理コードに属している場合は、Visitorデザインパターンなどのダブルディスパッチソリューションを検討してください。これにより、オブジェクト自体の外部にあるファシリティが、組み込み型システムを使用してクラスの型を判別できるようになります。
プログラムのロジックが、基本クラスの特定のインスタンスが実際には特定の派生クラスのインスタンスであることを保証する場合、 `dynamic_cast`をオブジェクトで自由に使用できます。通常、このような状況では、代わりに `static_cast`を使用できます。
タイプに基づく決定木は、コードが間違った方向に進んでいることを強く示しています。
このようなコードは通常、クラス階層にサブクラスが追加されると壊れます。さらに、サブクラスのプロパティが変更されると、影響を受けるすべてのコードセグメントを見つけて変更することは困難です。
RTTIのような回避策を手動で実装しないでください。RTTIに対する議論は、型タグを持つクラス階層のような回避策にも同じように適用されます。さらに、回避策はあなたの本当の意図を偽装します。
###キャスティング
`static_cast <float>（double_value）`のようなC ++スタイルのキャストを使用するか、 `int64 y = int64 {1} << 42`のような算術型の変換に中括弧の初期化を使用します。キャストが `void`でない限り、`（int）x`のようなキャストフォーマットを使用しないでください。`T`がクラス型の場合にのみ、` T（x） `のようなキャスト形式を使用できます。
C ++は、キャスト操作のタイプを区別するCとは異なるキャストシステムを導入しました。
Cキャストの問題は、操作のあいまいさです。_conversion_（例： `（int）3.5`）を実行している場合もあれば、_cast_（例：`（int） "hello" `）を実行している場合もあります。ブレースの初期化とC ++キャストは、多くの場合、このあいまいさを回避するのに役立ちます。さらに、C ++キャストは、それらを検索するときに見やすくなります。
C ++スタイルのキャスト構文は、冗長で面倒です。
通常、Cスタイルのキャストは使用しないでください。代わりに、明示的な型変換が必要な場合は、これらのC ++スタイルのキャストを使用してください。
*中括弧の初期化を使用して算術型を変換します（例： `int64 {x}`）。変換によって情報が失われる可能性がある場合、コードはコンパイルされないため、これが最も安全なアプローチです。構文も簡潔です。 *クラスからそのスーパークラスにポインタを明示的にアップキャストする必要がある場合、またはスーパークラスからスーパークラスにポインタを明示的にキャストする必要がある場合は、値の変換を行うCスタイルのキャストと同等の `static_cast`を使用します。サブクラス。この最後のケースでは、オブジェクトが実際にサブクラスのインスタンスであることを確認する必要があります。 * `const_cast`を使用して、` const`修飾子を削除します（constを参照）。 * `reinterpret_cast`を使用して、整数およびその他のポインター型との間のポインター型の安全でない変換を行います。これは、自分が何をしているかを理解していて、エイリアシングの問題を理解している場合にのみ使用してください。また、代替の `absl :: bit_cast`を検討してください。 * `absl :: bit_cast`を使用して、` double`のビットを `int64`として解釈するなど、同じサイズの異なるタイプ（型のパンニング）を使用して値の生のビットを解釈します。
`dynamic_cast`の使用に関するガイダンスについては、RTTIセクションを参照してください。
###ストリーム
必要に応じてストリームを使用し、「単純な」使用法に固執します。値を表すタイプのみをストリーミングするために `<<`をオーバーロードし、実装の詳細ではなく、ユーザーに表示される値のみを書き込みます。
ストリームは、標準ヘッダー `<iostream>`で例示されているように、C ++の標準I / O抽象化です。これらは、主にデバッグログとテスト診断のためにGoogleコードで広く使用されています。
`<<`および `>>`ストリーム演算子は、簡単に学習でき、移植可能で、再利用可能で、拡張可能なフォーマット済みI / O用のAPIを提供します。対照的に、 `printf`は、ユーザー定義型は言うまでもなく、` std :: string`もサポートしておらず、移植性のある使用は非常に困難です。`printf`では、その関数のわずかに異なる多数のバージョンから選択し、数十の変換指定子をナビゲートする必要もあります。
ストリームは、 `std :: cin`、` std :: cout`、 `std :: cerr`、および` std :: clog`を介してコンソールI / Oのファーストクラスのサポートを提供します。C APIも同様ですが、入力を手動でバッファリングする必要があるために妨げられます。
*ストリームのフォーマットは、ストリームの状態を変更することで構成できます。このような変更は永続的であるため、他のコードがアクセスするたびに既知の状態に復元するために邪魔にならない限り、コードの動作はストリームの以前の履歴全体の影響を受ける可能性があります。ユーザーコードは、組み込みの状態を変更できるだけでなく、登録システムを介して新しい状態変数と動作を追加できます。 *上記の問題、ストリーミングコードでのコードとデータの混合方法、および演算子のオーバーロード（予想とは異なるオーバーロードを選択する可能性がある）の使用により、ストリーム出力を正確に制御することは困難です。 * `<<`演算子のチェーンを介して出力を構築する方法は、語順をコードに焼き付け、ストリームのローカリゼーションのサポートが[欠陥]であるため、国際化を妨げます（http://www.boost.org/doc /libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why）。 *ストリームAPIは微妙で複雑なので、プログラマーはそれを効果的に使用するために経験を積む必要があります。 * `<<`の多くのオーバーロードを解決することは、コンパイラにとって非常にコストがかかります。大規模なコードベースで広く使用されている場合、解析およびセマンティック分析時間の20％を消費する可能性があります。
ストリームは、ジョブに最適なツールである場合にのみ使用してください。これは通常、I / Oがアドホックで、ローカルで、人間が読める形式であり、エンドユーザーではなく他の開発者を対象としている場合に当てはまります。あなたの周りのコード、そして全体としてのコードベースと一貫性を保ってください。問題に対して確立されたツールがある場合は、代わりにそのツールを使用してください。特に、ログライブラリは通常、診断出力には「std :: cerr」または「std :: clog」よりも適切な選択であり、「absl / strings」または同等のライブラリは通常「std ::」よりも適切な選択です。stringstream`。
外部ユーザーに直面したり、信頼できないデータを処理したりするI / Oにストリームを使用することは避けてください。代わりに、適切なテンプレートライブラリを見つけて使用し、国際化、ローカリゼーション、セキュリティ強化などの問題を処理します。
ストリームを使用する場合は、 `imbue（）`、 `xalloc（）`、 `register_callback（）`などのストリームAPIのステートフル部分（エラー状態以外）を避けてください。基数、精度、パディングなどのフォーマットの詳細を制御するには、ストリームマニピュレータやフォーマットフラグではなく、明示的なフォーマット関数（ `absl / strings`などを参照）を使用します。
タイプが値を表す場合にのみ、タイプのストリーミング演算子として `<<`をオーバーロードし、 `<<`はその値の人間が読める文字列表現を書き出します。`<<`の出力で実装の詳細を公開することは避けてください。デバッグのためにオブジェクトの内部を出力する必要がある場合は、代わりに名前付き関数を使用してください（ `DebugString（）`という名前のメソッドが最も一般的な規則です）。
###事前インクリメントと事前デクリメント
接尾辞のセマンティクスが必要でない限り、インクリメント演算子とデクリメント演算子のプレフィックス形式（ `++ i`）を使用します。
変数がインクリメント（ `++ i`または` i ++ `）またはデクリメント（` --i`または `i--`）され、式の値が使用されない場合、プリインクリメント（デクリメント）するかどうかを決定する必要があります。またはポストインクリメント（デクリメント）。
接尾辞のインクリメント/デクリメント式は、_変更前の値_に評価されます。これにより、コードはよりコンパクトになりますが、読みにくくなる可能性があります。プレフィックス形式は、一般的に読みやすく、効率が低下することはなく、操作前のように値のコピーを作成する必要がないため、効率が高くなる可能性があります。
Cでは、特に `for`ループで式の値が使用されていない場合でも、ポストインクリメントを使用するという伝統が発展しました。英語と同じように、「主語」（ `i`）が「動詞」（` ++ `）の前にあるため、ポストインクリメントが読みやすいと感じる人もいます。
コードが接尾辞のインクリメント/デクリメント式の結果を明示的に必要としない限り、プレフィックスのインクリメント/デクリメントを使用します。
### constの使用
APIでは、意味がある場合は常に `const`を使用します。`constexpr`は、constのいくつかの使用法に適しています。
宣言された変数とパラメーターの前にキーワード `const`を付けて、変数が変更されていないことを示すことができます（例：` const int foo`）。クラス関数は、関数がクラスメンバー変数の状態を変更しないことを示すために `const`修飾子を持つことができます（例：` class Foo {int Bar（char c）const;}; `）。
変数がどのように使用されているかを人々が理解しやすくなります。コンパイラがより良い型チェックを実行できるようにし、おそらくより良いコードを生成できるようにします。呼び出す関数が変数の変更方法に制限があることを知っているので、人々がプログラムの正当性を確信するのに役立ちます。マルチスレッドプログラムでロックなしで安全に使用できる関数を人々が知るのに役立ちます。
`const`はバイラルです。`const`変数を関数に渡す場合、その関数のプロトタイプには` const`が含まれている必要があります（そうでない場合、変数には `const_cast`が必要です）。これは、ライブラリ関数を呼び出すときに特に問題になる可能性があります。
API（つまり、関数パラメーター、メソッド、および非ローカル変数）で、意味があり正確な場合は常に `const`を使用することを強くお勧めします。これにより、操作が変更できるオブジェクトについて、一貫性のある、ほとんどコンパイラで検証されたドキュメントが提供されます。読み取りと書き込みを区別するための一貫性のある信頼性の高い方法を持つことは、スレッドセーフなコードを作成するために重要であり、他の多くのコンテキストでも役立ちます。特に：
*関数が、参照またはポインターによって渡された引数を変更しないことを保証する場合、対応する関数パラメーターは、constへの参照（ `const T＆`）またはconstへのポインター（ `const T *`）である必要があります。、それぞれ。*値で渡される関数パラメーターの場合、 `const`は呼び出し元に影響を与えないため、関数宣言では推奨されません。[TotW#109]（https://abseil.io/tips/109）を参照してください。*メソッドがオブジェクトの論理状態を変更しない限り（または、非const参照を返すなどしてユーザーがその状態を変更できるようにするが、それはまれです）、または安全に呼び出すことができない場合を除いて、メソッドを `const`として宣言します。同時に。
ローカル変数で `const`を使用することは、推奨も推奨もされていません。
クラスのすべての `const`操作は、互いに同時に呼び出すことが安全である必要があります。それが不可能な場合は、クラスを「スレッドセーフ」として明確に文書化する必要があります。
#### constを配置する場所
`const int * foo`よりも` int const * foo`の形式を好む人もいます。彼らは、これはより一貫性があるのでより読みやすいと主張します：それは `const`がそれが記述しているオブジェクトに常に続くという規則を守ります。ただし、ほとんどの `const`式には` const`が1つしかないため、この整合性引数は、深くネストされたポインタ式がほとんどないコードベースには適用されず、基になる値に適用されます。このような場合、維持する一貫性はありません。「const」を最初に置くことは、「名詞」（ `int`）の前に「形容詞」（` const`）を置くことで英語に従うので、間違いなく読みやすくなります。
とはいえ、 `const`を最初に置くことをお勧めしますが、必須ではありません。しかし、あなたの周りのコードと一致してください！
### constexprの使用
`constexpr`を使用して、真の定数を定義するか、定数の初期化を確実にします。
一部の変数は、変数が真の定数であることを示すために `constexpr`として宣言できます。つまり、コンパイル/リンク時に修正されます。一部の関数とコンストラクターは `constexpr`として宣言でき、` constexpr`変数の定義に使用できます。
`constexpr`を使用すると、リテラルだけでなく浮動小数点式を使用して定数を定義できます。ユーザー定義型の定数の定義。関数呼び出しによる定数の定義。
何かをconstexprとして時期尚早にマークすると、後でダウングレードする必要がある場合に移行の問題が発生する可能性があります。constexpr関数およびコンストラクターで許可されるものに関する現在の制限により、これらの定義であいまいな回避策が発生する可能性があります。
`constexpr`定義により、インターフェースの定数部分のより堅牢な仕様が可能になります。`constexpr`を使用して、真の定数とその定義をサポートする関数を指定します。関数定義を複雑にして `constexpr`で使用できるようにすることは避けてください。インライン化を強制するために `constexpr`を使用しないでください。
###整数型
組み込みのC ++整数型のうち、使用されるのは `int`だけです。プログラムに異なるサイズの変数が必要な場合は、 `int16_t`などの` <stdint.h> `の正確な幅の整数型を使用してください。変数が2 ^ 31（2GiB）以上の値を表す場合は、 `int64_t`などの64ビット型を使用してください。値が `int`に対して大きすぎない場合でも、より大きな型が必要になる可能性がある中間計算で使用される可能性があることに注意してください。疑わしい場合は、より大きなタイプを選択してください。
C ++は、 `int`のような整数型のサイズを指定しません。通常、「short」は16ビット、「int」は32ビット、「long」は32ビット、「longlong」は64ビットであると考えられています。
宣言の均一性。
C ++の整数型のサイズは、コンパイラーとアーキテクチャーによって異なります。
`<cstdint>`は、 `int16_t`、` uint32_t`、 `int64_t`などのタイプを定義します。保証が必要な場合は、常に` short`、 `unsigned longlong`などよりも優先して使用する必要があります。整数のサイズ。C整数型のうち、 `int`のみを使用する必要があります。必要に応じて、 `size_t`や` ptrdiff_t`などの標準タイプを使用できます。
ループカウンターのように、大きくなりすぎないことがわかっている整数の場合、 `int`を頻繁に使用します。そのようなことには、昔ながらの `int`を使用してください。`int`は少なくとも32ビットであると想定する必要がありますが、32ビットを超えると想定しないでください。64ビット整数型が必要な場合は、 `int64_t`または` uint64_t`を使用してください。
「大きい」可能性があることがわかっている整数の場合は、 `int64_t`を使用します。
数値ではなくビットパターンを表すなどの正当な理由がある場合、または2 ^ Nを法として定義されたオーバーフローが必要な場合を除いて、 `uint32_t`などの符号なし整数型は使用しないでください。特に、数値が負になることは決してないという意味で、符号なしの型を使用しないでください。代わりに、これにはアサーションを使用してください。
コードがサイズを返すコンテナーである場合は、コンテナーの可能な使用法に対応できるタイプを使用してください。疑わしい場合は、小さいタイプではなく大きいタイプを使用してください。
整数型を変換するときは注意してください。整数の変換と昇格は、未定義の動作を引き起こし、セキュリティバグやその他の問題を引き起こす可能性があります。
####符号なし整数について
符号なし整数は、ビットフィールドとモジュラー演算を表すのに適しています。歴史的な事故のため、C ++標準では、コンテナのサイズを表すために符号なし整数も使用しています。標準化団体の多くのメンバーは、これは間違いだと信じていますが、現時点で修正することは事実上不可能です。符号なし演算は単純な整数の動作をモデル化せず、代わりにモジュラー演算（オーバーフロー/アンダーフローでラップアラウンド）をモデル化する標準によって定義されるという事実は、重要なクラスのバグをコンパイラーが診断できないことを意味します。その他の場合、定義された動作が最適化を妨げます。
とはいえ、整数型の符号の混合は、同様に大きなクラスの問題の原因です。私たちが提供できる最善のアドバイスは、ポインターとサイズではなくイテレーターとコンテナーを使用するようにし、符号を混在させないようにし、符号なしの型を避けるようにする（ビットフィールドまたはモジュラー演算の表現を除く）。変数が負でないことを主張するためだけに符号なし型を使用しないでください。
### 64ビットの移植性
コードは64ビットおよび32ビットに対応している必要があります。印刷、比較、構造アラインメントの問題に留意してください。
*一部の整数typedefの正しいポータブル `printf（）`変換指定子は、使用するのが不快で非現実的であると思われるマクロ展開に依存しています（ `<cinttypes>`の `PRI`マクロ）。特定のケースに合理的な代替手段がない場合を除いて、 `printf`ファミリーに依存するAPIを回避またはアップグレードするようにしてください。代わりに、[`StrCat`]（https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h）や[` Substitute`]（などのタイプセーフな数値フォーマットをサポートするライブラリを使用してくださいhttps://github.com/abseil/abseil-cpp/blob/master/absl/strings/substitute.h）高速で単純な変換、または `std :: ostream`。
残念ながら、 `PRI`マクロは、標準のビット幅typedef（` int64_t`、 `uint64_t`、` int32_t`、 `uint32_t`など）の変換を指定する唯一の移植可能な方法です。可能な場合は、ビット幅typedefで指定された型の引数を `printf`ベースのAPIに渡さないでください。printfに `size_t`（` z`）、 `ptrdiff_t`（` t`）、 `maxint_t`（` j`）などの専用の長さ修飾子があるtypedefを使用することが許容されることに注意してください。
* `sizeof（void *）`！= `sizeof（int）`であることを忘れないでください。ポインタサイズの整数が必要な場合は、 `intptr_t`を使用してください。*特にディスクに保存されている構造体の場合、構造アラインメントに注意する必要がある場合があります。`int64_t` /` uint64_t`メンバーを持つクラス/構造は、デフォルトで64ビットシステム上で8バイトに整列されます。このような構造が32ビットコードと64ビットコードの間でディスク上で共有されている場合は、両方のアーキテクチャで同じようにパックされていることを確認する必要があります。ほとんどのコンパイラは、構造アラインメントを変更する方法を提供します。gccの場合、 `__attribute __（（packed））`を使用できます。MSVCは、 `#pragma pack（）`と `__declspec（align（））`を提供します。* 64ビット定数を作成するには、必要に応じてブレース初期化を使用します。例えば：
###プリプロセッサマクロ
特にヘッダーでマクロを定義することは避けてください。インライン関数、列挙型、および `const`変数を優先します。プロジェクト固有のプレフィックスを付けてマクロに名前を付けます。マクロを使用してC ++ APIの一部を定義しないでください。
マクロは、表示されるコードがコンパイラーが表示するコードと同じではないことを意味します。これは、特にマクロがグローバルスコープを持っているため、予期しない動作を引き起こす可能性があります。
マクロによって引き起こされる問題は、C ++ APIの一部を定義するために使用される場合に特に深刻であり、パブリックAPIの場合はさらに深刻です。開発者がそのインターフェイスを誤って使用した場合のコンパイラからのすべてのエラーメッセージは、マクロがどのようにインターフェイスを形成したかを説明する必要があります。リファクタリングおよび分析ツールは、インターフェースの更新に劇的に苦労します。結果として、この方法でマクロを使用することは特に禁止されています。たとえば、次のようなパターンは避けてください。
幸い、C ++ではマクロはCほど必要ではありません。マクロを使用してパフォーマンスが重要なコードをインライン化する代わりに、インライン関数を使用してください。マクロを使用して定数を格納する代わりに、 `const`変数を使用します。マクロを使用して長い変数名を「短縮」する代わりに、参照を使用してください。マクロを使用してコードを条件付きでコンパイルする代わりに...まあ、それはまったく行わないでください（もちろん、ヘッダーファイルの二重インクルードを防ぐための `#define`ガードを除く）。それはテストをはるかに難しくします。
マクロは、これらの他の手法では実行できないことを実行でき、コードベース、特に低レベルのライブラリでそれらを確認できます。また、それらの特別な機能の一部（文字列化、連結など）は、適切な言語では使用できません。ただし、マクロを使用する前に、同じ結果を達成するための非マクロの方法があるかどうかを慎重に検討してください。マクロを使用してインターフェイスを定義する必要がある場合は、プロジェクトリードに連絡して、このルールの免除を要求してください。
次の使用パターンは、マクロに関する多くの問題を回避します。マクロを使用する場合は、可能な限りそれに従ってください。
* `.h`ファイルでマクロを定義しないでください。*使用する直前の `#define`マクロ、および使用直後の`#undef`。*既存のマクロを独自のマクロに置き換える前に単に `#undef`しないでください。代わりに、一意である可能性が高い名前を選択してください。*不均衡なC ++構造に展開するマクロを使用しないようにするか、少なくともその動作を適切に文書化してください。*関数/クラス/変数名の生成に `##`を使用しないことをお勧めします。
ヘッダーからマクロをエクスポートする（つまり、ヘッダーの終わりの前にマクロを「#undef」せずにヘッダーで定義する）ことは、非常に強くお勧めしません。ヘッダーからマクロをエクスポートする場合は、グローバルに一意の名前を付ける必要があります。これを実現するには、プロジェクトの名前空間名（ただし大文字）で構成されるプレフィックスを付けて名前を付ける必要があります。
### 0およびnullptr / NULL
ポインタには `nullptr`を使用し、文字には` '\ 0'`を使用します（ `0`リテラルではありません）。
ポインタ（アドレス値）には、タイプセーフを提供するため、 `nullptr`を使用します。
C ++ 03プロジェクトの場合、 `0`よりも` NULL`を優先します。値は同等ですが、 `NULL`はリーダーへのポインターのように見え、一部のC ++コンパイラーは、有用な警告を与えることができる` NULL`の特別な定義を提供します。数値（整数または浮動小数点）に「NULL」を使用しないでください。
ヌル文字には `'\ 0'`を使用します。正しいタイプを使用すると、コードが読みやすくなります。
### のサイズ
`sizeof（type）`よりも `sizeof（varname）`を優先します。
特定の変数のサイズを取得する場合は、 `sizeof（varname）`を使用します。`sizeof（varname）`は、誰かが変数タイプを現在または後で変更した場合に適切に更新されます。適切なC ++タイプの変数が便利でない外部または内部データ形式を管理するコードなど、特定の変数に関係のないコードには、 `sizeof（type）`を使用できます。
###型控除（自動を含む）
型控除は、プロジェクトに精通していない読者にとってコードが明確になる場合、またはコードが安全になる場合にのみ使用してください。明示的な型を書く不便さを避けるためだけに使用しないでください。
C ++では、コードで明示的に説明するのではなく、コンパイラーが型を推測できる（または必要とする）コンテキストがいくつかあります。
[関数テンプレートの引数の推定]（https://en.cppreference.com/w/cpp/language/template_argument_deduction）
関数テンプレートは、明示的なテンプレート引数なしで呼び出すことができます。コンパイラーは、関数の引数の型からこれらの引数を推測します。
[`auto`変数宣言]（https://en.cppreference.com/w/cpp/language/auto）
変数宣言では、型の代わりに `auto`キーワードを使用できます。コンパイラーは、同じ初期化子を使用した関数テンプレートの引数の推定と同じ規則に従って、変数の初期化子から型を推定します（括弧の代わりに中括弧を使用しない場合）。
`auto`は` const`で修飾でき、ポインタまたは参照型の一部として使用できますが、テンプレート引数として使用することはできません。この構文のまれな変形では、 `auto`の代わりに` decltype（auto） `が使用されます。この場合、推定される型は[` decltype`]（https://en.cppreference.com/w/cpp/言語/ decltype）を初期化子に。
[関数の戻り値の型の推定]（https://en.cppreference.com/w/cpp/language/function#Return_type_deduction）
関数の戻り値の型の代わりに `auto`（および` decltype（auto） `）を使用することもできます。コンパイラは、変数宣言の場合と同じ規則に従って、関数本体の `return`ステートメントから戻り値の型を推測します。
ラムダ式の戻り値の型も同じ方法で推測できますが、これは明示的な `auto`ではなく、戻り値の型を省略することでトリガーされます。紛らわしいことに、関数の末尾の戻り値の型の構文も、戻り値の型の位置で `auto`を使用しますが、これは型の推定に依存しません。これは、明示的な戻り値の型の単なる代替構文です。
[一般的なラムダ]（https://isocpp.org/wiki/faq/cpp14-language#generic-lambdas）
ラムダ式では、1つ以上のパラメータータイプの代わりに `auto`キーワードを使用できます。これにより、ラムダの呼び出し演算子は通常の関数ではなく関数テンプレートになり、「auto」関数パラメーターごとに個別のテンプレートパラメーターが使用されます。
[Lambda initcaptures]（https://isocpp.org/wiki/faq/cpp14-language#lambda-captures）
Lambdaキャプチャには、明示的なイニシャライザを含めることができます。これを使用して、既存の変数だけをキャプチャするのではなく、まったく新しい変数を宣言できます。
この構文では、タイプを指定できません。代わりに、 `auto`変数のルールを使用して推定されます。
[クラステンプレート引数の推定]（https://en.cppreference.com/w/cpp/language/class_template_argument_deduction）
下記参照。[構造化バインディング]（https://en.cppreference.com/w/cpp/language/structured_binding）
`auto`を使用してタプル、構造体、または配列を宣言する場合、オブジェクト全体の名前ではなく、個々の要素の名前を指定できます。これらの名前は「構造化バインディング」と呼ばれ、宣言全体は「構造化バインディング宣言」と呼ばれます。この構文では、囲んでいるオブジェクトまたは個々の名前のタイプを指定する方法はありません。
`auto`は` const`、 `＆`、 `&&`で修飾することもできますが、これらの修飾子は技術的には個々のバインディングではなく、匿名のタプル/構造体/配列に適用されることに注意してください。バインディングのタイプを決定するルールは非常に複雑です。宣言が参照を宣言している場合でも、バインディングタイプは通常参照ではないことを除いて、結果は驚くべきことではない傾向があります（ただし、通常は参照のように動作します）。
（これらの要約では、多くの詳細と警告が省略されています。詳細については、リンクを参照してください。）
* C ++の型名は、特にテンプレートや名前空間が含まれる場合、長くて扱いにくい場合があります。* C ++型名が単一の宣言または小さなコード領域内で繰り返される場合、その繰り返しは読みやすさを助けない可能性があります。*意図しないコピーや型変換の可能性を回避するため、型を推測する方が安全な場合があります。
C ++コードは通常、型が明示的である場合、特に型の推定がコードの離れた部分からの情報に依存する場合に、より明確になります。次のような式で：
`y`のタイプがあまりよく知られていない場合、または` y`が何行も前に宣言されている場合、結果のタイプが何であるかが明確でない場合があります。
プログラマーは、型の推定によって参照型が生成される場合と生成されない場合を理解する必要があります。そうしないと、意図しないときにコピーを取得します。
推定型がインターフェースの一部として使用されている場合、プログラマーは値を変更することだけを意図して型を変更する可能性があり、意図したよりも根本的なAPIの変更につながります。
基本的なルールは次のとおりです。型の推定は、コードをより明確または安全にするためにのみ使用し、明示的な型を作成する不便さを避けるためだけに使用しないでください。コードがより明確であるかどうかを判断するときは、読者が必ずしもチームに所属しているとは限らず、プロジェクトに精通しているとは限らないことに注意してください。そのため、あなたとレビュー担当者が不必要な混乱として経験するタイプは、他の人に役立つ情報を提供することがよくあります。たとえば、 `make_unique <Foo>（）`の戻り値の型は明らかであると想定できますが、 `MyWidgetFactory（）`の戻り値の型はおそらくそうではありません。
これらの原則はすべての形式の型推論に適用されますが、次のセクションで説明するように、詳細は異なります。
####関数テンプレートの引数の演繹
関数テンプレートの引数の推定は、ほとんどの場合OKです。型控除は、関数テンプレートが通常の関数オーバーロードの無限セットのように機能することを可能にするため、関数テンプレートと対話するための予想されるデフォルトの方法です。したがって、関数テンプレートは、ほとんどの場合、テンプレート引数の推定が明確で安全であるか、コンパイルされないように設計されています。
####ローカル変数タイプの推定
ローカル変数の場合、型推定を使用して、明白または無関係な型情報を削除することでコードを明確にし、読者がコードの意味のある部分に集中できるようにすることができます。
タイプには、上記の例の「it」のように、有用な情報と定型文が混在している場合があります。タイプがイテレータであることは明らかであり、多くの場合、コンテナタイプやキータイプも関係ありませんが、タイプは関係ありません。値のうち、おそらく有用です。このような状況では、関連情報を伝達する明示的な型を使用してローカル変数を定義できることがよくあります。
タイプがテンプレートインスタンスであり、パラメーターがボイラープレートであるが、テンプレート自体が有益である場合、クラステンプレート引数の推定を使用してボイラープレートを抑制することができます。ただし、これが実際に意味のある利点を提供するケースは非常にまれです。クラステンプレートの引数の推定も、別のスタイルルールの対象となることに注意してください。
より単純なオプションが機能する場合は、 `decltype（auto）`を使用しないでください。これはかなりあいまいな機能であるため、コードの明確化に高いコストがかかります。
####戻り値の型の控除
関数本体に `return`ステートメントの数が非常に少なく、他のコードがほとんどない場合にのみ、戻り値の型の推定（関数とラムダの両方）を使用します。そうしないと、読者が戻り値の型を一目で判断できない可能性があります。です。さらに、戻り値の型が推定される関数は抽象化の境界を定義しないため、関数またはラムダのスコープが非常に狭い場合にのみ使用してください。実装はインターフェイスです。特に、ヘッダーファイルのパブリック関数が戻り値の型を推測することはほとんどありません。
####パラメータタイプの推定
ラムダの `auto`パラメータタイプは注意して使用する必要があります。実際のタイプは、ラムダの定義ではなく、ラムダを呼び出すコードによって決定されるためです。その結果、ラムダが定義された場所の非常に近くで明示的に呼び出されない限り（読者が両方を簡単に確認できるように）、またはラムダが非常によく知られているインターフェイスに渡されて、どの引数が明確であるかが明らかでない限り、明示的な型はほとんど常に明確になります最終的にはで呼び出されます（たとえば、上記の `std :: sort`の例）。
#### Lambdainitキャプチャ
Initキャプチャは、より具体的なスタイルルールでカバーされます。これは、型推定の一般的なルールに大きく優先します。
####構造化バインディング
他の形式の型推論とは異なり、構造化バインディングは、より大きなオブジェクトの要素に意味のある名前を付けることにより、実際に読者に追加情報を与えることができます。これは、構造化されたバインディング宣言が、 `auto`が提供しない場合でも、明示的な型よりも正味の可読性を向上させる可能性があることを意味します。構造化バインディングは、オブジェクトがペアまたはタプルである場合（上記の「挿入」の例のように）、最初から意味のあるフィールド名がないため特に有益ですが、通常はペアまたはタプルを使用しないでください。`insert`のような既存のAPIはあなたに強制します。
バインドされているオブジェクトが構造体である場合は、使用法に固有の名前を指定すると役立つ場合がありますが、これは、フィールド名よりも名前が読者に認識されにくいことを意味する場合があることに注意してください。バインディングの名前と一致しない場合は、関数パラメーターのコメントと同じ構文を使用して、基になるフィールドの名前を示すためにコメントを使用することをお勧めします。
関数パラメーターのコメントと同様に、これにより、ツールがフィールドの順序が間違っているかどうかを検出できるようになります。
###クラステンプレートの引数の推定
クラステンプレート引数の推定は、それをサポートすることを明示的に選択したテンプレートでのみ使用してください。
[クラステンプレート引数の推定]（https://en.cppreference.com/w/cpp/language/class_template_argument_deduction）（「CTAD」と略されることが多い）は、変数がテンプレートに名前を付ける型で宣言されている場合に発生し、テンプレート引数はリストは提供されていません（空の山括弧もありません）：
コンパイラーは、テンプレートの「推定ガイド」を使用して、初期化子から引数を推定します。これは、明示的または暗黙的です。
明示的な推論ガイドは、先頭に「auto」がなく、関数名がテンプレートの名前であることを除いて、戻り値の型が末尾にある関数宣言のように見えます。たとえば、上記の例は、 `std :: array`のこの推定ガイドに依存しています。
（テンプレートの特殊化とは対照的に）プライマリテンプレートのコンストラクターも、推論ガイドを暗黙的に定義します。
CTADに依存する変数を宣言すると、コンパイラーはコンストラクターの過負荷解決のルールを使用して演繹ガイドを選択し、そのガイドの戻り値の型が変数の型になります。
CTADを使用すると、コードから定型文を省略できる場合があります。
コンストラクターから生成される暗黙の演繹ガイドは、望ましくない動作をするか、完全に正しくない可能性があります。これは、CTADがC ++ 17に導入される前に作成されたコンストラクターにとって特に問題です。これらのコンストラクターの作成者は、コンストラクターがCTADに引き起こす問題について知る方法がなかったためです。さらに、これらの問題を修正するために明示的な演繹ガイドを追加すると、暗黙的な演繹ガイドに依存する既存のコードが破損する可能性があります。
CTADは、初期化子から変数の型の全部または一部を推測するためのメカニズムであるため、 `auto`と同じ欠点の多くにも悩まされています。CTADは、読者に「自動」よりも多くの情報を提供しますが、情報が省略されているという明白な手がかりも読者に提供しません。
テンプレートのメンテナが少なくとも1つの明示的な推論ガイドを提供することによってCTADの使用をサポートすることを選択していない限り、特定のテンプレートでCTADを使用しないでください（ `std`名前空間内のすべてのテンプレートもオプトインしていると見なされます）。これは、可能な場合はコンパイラ警告で強制する必要があります。
CTADの使用は、型の推定に関する一般的な規則にも従う必要があります。
###指定されたイニシャライザー
指定された初期化子は、C ++ 20準拠の形式でのみ使用してください。
[指定された初期化子]（https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers）は、フィールドに明示的に名前を付けることで集計（ "plain old struct"）を初期化できる構文です。
明示的にリストされたフィールドは指定どおりに初期化され、その他のフィールドは、 `Point {1.0、2.0}`などの従来の集計初期化式と同じ方法で初期化されます。
指定されたイニシャライザーは、特に上記の「Point」の例よりもフィールドの順序が単純でない構造体の場合に、便利で読みやすい集計式を作成できます。
指定されたイニシャライザーは長い間C標準の一部であり、拡張機能としてC ++コンパイラーによってサポートされてきましたが、ドラフトC ++標準に組み込まれたのはごく最近のことです。それらはC ++ 20での公開に向けて順調に進んでいます。
ドラフトC ++標準のルールは、Cおよびコンパイラ拡張よりも厳格であり、指定されたイニシャライザが構造体定義に表示されるフィールドと同じ順序で表示される必要があります。したがって、上記の例では、ドラフトC ++ 20に従って、 `x`、次に` z`を初期化することは合法ですが、 `y`、次に` x`を初期化することは合法です。
指定された初期化子は、ドラフトC ++ 20標準と互換性のある形式でのみ使用してください。対応するフィールドが構造体定義に表示されるのと同じ順序で初期化子を使用します。
###ラムダ式
必要に応じてラムダ式を使用します。ラムダが現在のスコープをエスケープする場合は、明示的なキャプチャを優先します。
ラムダ式は、無名関数オブジェクトを作成するための簡潔な方法です。これらは、関数を引数として渡すときに役立つことがよくあります。例えば：
さらに、名前で明示的に、またはデフォルトのキャプチャを使用して暗黙的に、囲んでいるスコープから変数をキャプチャできます。明示的なキャプチャでは、値または参照キャプチャのいずれかとして、各変数をリストする必要があります。
デフォルトのキャプチャは、ラムダ本体で参照されている変数を暗黙的にキャプチャします。これには、メンバーが使用されている場合の「this」も含まれます。
変数キャプチャには、明示的な初期化子を含めることもできます。これは、移動のみの変数を値でキャプチャするため、または通常の参照や値のキャプチャでは処理されないその他の状況で使用できます。
このようなキャプチャ（「initキャプチャ」または「一般化ラムダキャプチャ」と呼ばれることが多い）は、実際には、囲んでいるスコープから何かを「キャプチャ」する必要はなく、囲んでいるスコープから名前を付ける必要もありません。この構文は、ラムダオブジェクトのメンバーを定義するための完全に一般的な方法です。
イニシャライザを使用したキャプチャのタイプは、 `auto`と同じルールを使用して推定されます。
*ラムダは、STLアルゴリズムに渡される関数オブジェクトを定義する他の方法よりもはるかに簡潔であり、読みやすさが向上する可能性があります。*デフォルトのキャプチャを適切に使用すると、冗長性がなくなり、デフォルトから重要な例外が強調表示されます。* Lambdas、 `std :: function`、および` std :: bind`は、汎用のコールバックメカニズムとして組み合わせて使用できます。有界関数を引数として取る関数を簡単に作成できます。
*ラムダでの変数キャプチャは、特にラムダが現在のスコープをエスケープする場合、ダングリングポインタのバグの原因となる可能性があります。 *値によるデフォルトのキャプチャは、ダングリングポインタのバグを防止しないため、誤解を招く可能性があります。ポインタを値でキャプチャしてもディープコピーは発生しないため、参照によるキャプチャと同じライフタイムの問題が発生することがよくあります。 'this'の使用は暗黙的であることが多いため、これは 'this'を値でキャプチャするときに特に混乱します。 *キャプチャは実際には（キャプチャに初期化子があるかどうかに関係なく）新しい変数を宣言しますが、C ++の他の変数宣言構文とはまったく異なります。特に、変数の型の場所はなく、「auto」プレースホルダーもありません（ただし、initキャプチャは、キャストなどで間接的に示すことができます）。これにより、それらを宣言として認識することさえ困難になる可能性があります。 * Initキャプチャは本質的に型の推論に依存しており、 `auto`と同じ欠点の多くに悩まされていますが、構文が推論が行われていることを読者に知らせないという追加の問題もあります。 *ラムダの使用が手に負えなくなる可能性があります。ネストされた匿名関数が非常に長いと、コードが理解しにくくなる可能性があります。
*必要に応じてラムダ式を使用し、以下に説明するフォーマットを使用します。*ラムダが現在のスコープをエスケープする可能性がある場合は、明示的なキャプチャを優先します。たとえば、次の代わりに：
書くことを好む：
*ラムダの存続期間が潜在的なキャプチャよりも明らかに短い場合にのみ、参照によるデフォルトのキャプチャ（[＆]）を使用します。*デフォルトの値によるキャプチャ（[=]）は、キャプチャされた変数のセットが一目でわかる短いラムダのいくつかの変数をバインドする手段としてのみ使用してください。デフォルトの値によるキャプチャを使用して、長いラムダや複雑なラムダを記述しないことをお勧めします。*キャプチャは、囲んでいるスコープから実際に変数をキャプチャする場合にのみ使用してください。イニシャライザでキャプチャを使用して新しい名前を導入したり、既存の名前の意味を大幅に変更したりしないでください。代わりに、従来の方法で新しい変数を宣言してからキャプチャするか、ラムダの省略形を避けて関数オブジェクトを明示的に定義してください。*パラメータと戻り値の型の指定に関するガイダンスについては、型の推定に関するセクションを参照してください。
###テンプレートメタプログラミング
複雑なテンプレートプログラミングは避けてください。
テンプレートメタプログラミングとは、C ++テンプレートインスタンス化メカニズムがチューリング完全であり、タイプドメインで任意のコンパイル時計算を実行するために使用できるという事実を利用する一連の手法を指します。
テンプレートメタプログラミングにより、タイプセーフで高性能な非常に柔軟なインターフェイスが可能になります。[Google Test]（https://github.com/google/googletest）、 `std :: tuple`、` std :: function`、Boost.Spiritなどの機能はそれなしでは不可能です。
テンプレートメタプログラミングで使用される手法は、言語の専門家以外にはわかりにくいことがよくあります。テンプレートを複雑な方法で使用するコードは、多くの場合、判読できず、デバッグや保守が困難です。
テンプレートメタプログラミングは、コンパイル時のエラーメッセージを非常に貧弱にすることがよくあります。インターフェイスが単純であっても、ユーザーが何か間違ったことをすると、複雑な実装の詳細が表示されます。
テンプレートメタプログラミングは、リファクタリングツールの作業を困難にすることにより、大規模なリファクタリングを妨害します。まず、テンプレートコードは複数のコンテキストで展開され、変換がそれらすべてで意味があることを確認するのは困難です。次に、一部のリファクタリングツールは、テンプレート展開後のコードの構造のみを表すASTで機能します。書き直す必要のある元のソース構成に自動的に戻すのは難しい場合があります。
テンプレートメタプログラミングにより、それがない場合よりもクリーンで使いやすいインターフェイスが可能になる場合がありますが、過度に巧妙になりたくなることもよくあります。余分なメンテナンスの負担が多数の用途に分散している少数の低レベルコンポーネントで使用するのが最適です。
テンプレートメタプログラミングやその他の複雑なテンプレート手法を使用する前に、よく考えてください。チームの平均的なメンバーが、別のプロジェクトに切り替えた後もコードを維持するのに十分なほどコードを理解できるかどうか、またはC ++以外のプログラマーやコードベースを何気なく閲覧している人がエラーメッセージを理解できるかどうかを考えてください。または、呼び出したい関数のフローをトレースします。再帰的なテンプレートのインスタンス化、タイプリスト、メタ関数、または式テンプレートを使用している場合、または関数のオーバーロード解決を検出するためにSFINAEまたは `sizeof`トリックに依存している場合は、行き過ぎている可能性があります。
テンプレートメタプログラミングを使用する場合は、複雑さを最小限に抑えて分離することにかなりの努力を払うことを期待する必要があります。ユーザー向けのヘッダーが読みやすくなるように、可能な限り実装の詳細としてメタプログラミングを非表示にする必要があります。また、トリッキーなコードに特に適切なコメントを付ける必要があります。コードがどのように使用されるかを注意深く文書化し、「生成された」コードがどのように見えるかについて何かを言う必要があります。ユーザーがミスをしたときにコンパイラーが出力するエラーメッセージに特に注意してください。エラーメッセージはユーザーインターフェイスの一部であり、ユーザーの観点からエラーメッセージを理解して実行できるように、必要に応じてコードを微調整する必要があります。
### ブースト
Boostライブラリコレクションから承認されたライブラリのみを使用してください。
[Boostライブラリコレクション]（https://www.boost.org/）は、ピアレビューされた無料のオープンソースC ++ライブラリの人気のあるコレクションです。
ブーストコードは一般に非常に高品質で、広く移植可能であり、型特性やより優れたバインダーなど、C ++標準ライブラリの多くの重要なギャップを埋めます。
一部のBoostライブラリは、メタプログラミングやその他の高度なテンプレート手法など、読みやすさを妨げる可能性のあるコーディング手法や、過度に「関数型」のプログラミングスタイルを推奨しています。
コードを読んで維持する可能性のあるすべての寄稿者に高レベルの可読性を維持するために、Boost機能の承認されたサブセットのみを許可します。現在、次のライブラリが許可されています。
* [Call Traits]（https://www.boost.org/libs/utility/call_traits.htm）from `boost / call_traits.hpp` * [Compressed Pair]（https://www.boost.org/libs/ユーティリティ/compressed_pa​​ir.htm）from `boost / compressed_pa​​ir.hpp` * [Boost Graph Library（BGL）]（https://www.boost.org/libs/graph/）from` boost / graph`、ただしシリアル化（ `adj_list_serialize.hpp`）および並列/分散アルゴリズムとデータ構造（` boost / graph / parallel / * `および` boost / graph / Distributed / * `）。 * [プロパティマップ]（https://www.boost.org/libs/property_map/） `boost / property_map`から。ただし並列/分散プロパティマップ（` boost / property_map / parallel / * `）は除きます。 * [Iterator]（https://www.boost.org/libs/iterator/）from `boost / iterator` * [Polygon]（https://www.boost.org/libs/polygon/）の一部Voronoiダイアグラムの構築を扱い、Polygonの残りの部分に依存しません： `boost / polygon / voronoi_builder.hpp`、` boost / polygon / voronoi_diagram.hpp`、および `boost / polygon / voronoi_geometry_type.hpp` * [Bimap] （https://www.boost.org/libs/bimap/）from `boost / bimap` * [統計的分布と関数]（https://www.boost.org/libs/math/doc/html/dist。 html）from `boost / math / distributions` * [特殊関数]（https://www.boost.org/libs/math/doc/html/special.html）from` boost / math / special_functions` * [ルート検索関数]（https://www.boost.org/libs/math/doc/html/root_finding.html）from `boost / math / tools` * [マルチインデックス]（https://www.boost.org/ libs / multi_index /）from `boost / multi_index` * [Heap]（https://www.boost.org/libs/heap/）from` boost / heap` * [Container]（https：// www.boost.org/libs/container /）： `boost / container / flat_map`、および` boost / container / flat_set` * [Intrusive]（https://www.boost.org/libs/intrusive/）from `boost / intrusive`。 * [`boost / sort`ライブラリ]（https://www.boost.org/libs/sort/）。 * `boost / preprocessor`の[プリプロセッサ]（https://www.boost.org/libs/preprocessor/）。
他のBoost機能をリストに追加することを積極的に検討しているため、このリストは将来拡張される可能性があります。
### std :: hash
`std :: hash`の特殊化を定義しないでください。
`std :: hash <T>`は、ユーザーが別のハッシュ関数を明示的に指定しない限り、C ++ 11ハッシュコンテナがタイプ `T`のキーをハッシュするために使用する関数オブジェクトです。たとえば、 `std :: unordered_map <int、std :: string>`は、 `std :: hash <int>`を使用してキーをハッシュするハッシュマップですが、 `std :: unordered_map <int、std :: string、MyIntHash> `は` MyIntHash`を使用します。
`std :: hash`は、すべての整数、浮動小数点、ポインター、および` enum`タイプ、および `string`や` unique_ptr`などのいくつかの標準ライブラリタイプに対して定義されています。ユーザーは、それらのタイプの特殊化を定義することにより、独自のタイプで機能できるようにすることができます。
`std :: hash`は使いやすく、明示的に名前を付ける必要がないため、コードが簡素化されます。`std :: hash`を特殊化することは、型をハッシュする方法を指定する標準的な方法であるため、外部のリソースが教えることであり、新しいエンジニアが期待することです。
`std :: hash`は専門化するのが難しいです。これには多くの定型コードが必要であり、さらに重要なことに、ハッシュ入力を識別する責任とハッシュアルゴリズム自体を実行する責任が組み合わされています。タイプ作成者は前者を担当する必要がありますが、後者はタイプ作成者が通常持っていない専門知識を必要とし、必要とすべきではありません。[ハッシュフラッディング攻撃]（https://emboss.github.io/blog/2012/12/14/breaking-murmur-hash）の出現により、低品質のハッシュ関数がセキュリティの脆弱性になる可能性があるため、ここでのリスクは高くなります。--flooding-dos-reloaded /）。
専門家でさえ、実装がデータメンバーに対して再帰的に `std :: hash`を呼び出すことができないため、` std :: hash`の特殊化を複合型に正しく実装することは非常に困難です。高品質のハッシュアルゴリズムは大量の内部状態を維持し、その状態を `std :: hash`が返す` size_t`バイトに減らすことは通常、計算の最も遅い部分であるため、複数回実行しないでください。
まさにその問題のため、 `std :: hash`は` std :: pair`または `std :: tuple`では機能せず、言語ではそれらをサポートするために拡張することはできません。
`std :: hash`は、「すぐに使える」サポートするタイプで使用できますが、追加のタイプをサポートするように特殊化することはできません。`std :: hash`がサポートしていないキータイプのハッシュテーブルが必要な場合は、今のところレガシーハッシュコンテナ（例：` hash_map`）の使用を検討してください。彼らは別のデフォルトのハッシャーを使用しますが、これはこの禁止の影響を受けません。
とにかく標準のハッシュコンテナを使用する場合は、キータイプにカスタムハッシャーを指定する必要があります。
タイプの所有者に相談して、使用できる既存のハッシャーがあるかどうかを確認してください。それ以外の場合は、彼らと協力して提供するか、自分で作成します。
`std :: hash`の欠点を持たない新しいカスタマイズメカニズムを使用して、任意のタイプで機能するハッシュ関数を提供することを計画しています。
###その他のC ++機能
Boostと同様に、一部の最新のC ++拡張機能は、読みやすさを妨げるコーディング手法を奨励しています。たとえば、読者に役立つ可能性のあるチェック済みの冗長性（タイプ名など）を削除したり、テンプレートメタプログラミングを奨励したりします。他の拡張機能は、既存のメカニズムで利用できる機能を複製するため、混乱や変換コストが発生する可能性があります。
スタイルガイドの残りの部分で説明されていることに加えて、次のC ++機能は使用できない場合があります。
*コンパイル時の有理数（ `<ratio>`）。これは、テンプレートを多用するインターフェイススタイルに関連付けられていることが懸念されるためです。* `<cfenv>`および `<fenv.h>`ヘッダー。多くのコンパイラーは、これらの機能を確実にサポートしていないためです。* `<filesystem>`ヘッダー。テストを十分にサポートしておらず、固有のセキュリティの脆弱性があります。
###非標準の拡張機能
特に指定がない限り、C ++の非標準拡張機能は使用できません。
コンパイラは、標準のC ++の一部ではないさまざまな拡張機能をサポートしています。このような拡張機能には、GCCの `__attribute__`、` __builtin_prefetch`などの組み込み関数、インラインアセンブリ、 `__COUNTER__`、` __PRETTY_FUNCTION__`、複合ステートメント式（たとえば、 `foo =（{int x; Bar（＆x）; x}）`が含まれます。、可変長配列と `alloca（）`、および "[Elvis Operator]（https://en.wikipedia.org/wiki/Elvis_operator）" `a？：b`。
*非標準の拡張機能は、標準のC ++には存在しない便利な機能を提供する場合があります。*コンパイラへの重要なパフォーマンスガイダンスは、拡張機能を使用してのみ指定できます。
*非標準の拡張機能はすべてのコンパイラで機能するわけではありません。非標準の拡張機能を使用すると、コードの移植性が低下します。*対象となるすべてのコンパイラでサポートされている場合でも、拡張機能が明確に指定されていないことが多く、コンパイラ間で微妙な動作の違いがある場合があります。*非標準の拡張機能は、読者がコードを理解するために知っておく必要のある言語機能を追加します。
非標準の拡張機能は使用しないでください。非標準の拡張機能を使用して実装された移植性ラッパーを使用できますが、それらのラッパーが指定されたプロジェクト全体の移植性ヘッダーによって提供されている場合に限ります。
###エイリアス
パブリックエイリアスはAPIのユーザーの利益のためであり、明確に文書化する必要があります。
他のエンティティのエイリアスである名前を作成するには、いくつかの方法があります。
新しいコードでは、 `using`は` typedef`よりも推奨されます。これは、C ++の他の部分とより一貫性のある構文を提供し、テンプレートで機能するためです。
他の宣言と同様に、ヘッダーファイルで宣言されたエイリアスは、関数定義、クラスのプライベート部分、または明示的にマークされた内部名前空間にない限り、そのヘッダーのパブリックAPIの一部です。このような領域または.ccファイル内のエイリアスは実装の詳細であり（クライアントコードがそれらを参照できないため）、このルールによって制限されません。
*エイリアスは、長い名前や複雑な名前を単純化することで、読みやすさを向上させることができます。*エイリアスは、APIで繰り返し使用されるタイプに名前を付けることで重複を減らすことができます。これにより、後でタイプを簡単に変更できる可能性があります。
*クライアントコードがそれらを参照できるヘッダーに配置されると、エイリアスはそのヘッダーのAPI内のエンティティの数を増やし、その複雑さを増します。*クライアントは、パブリックエイリアスの意図しない詳細に簡単に依存する可能性があるため、変更が困難になります。* APIや保守性への影響を考慮せずに、実装での使用のみを目的としたパブリックエイリアスを作成したくなる場合があります。*エイリアスは名前の衝突のリスクを生み出す可能性があります*エイリアスは馴染みのある構造に馴染みのない名前を付けることで読みやすさを低下させる可能性があります*タイプエイリアスは不明確なAPIコントラクトを作成する可能性があります：エイリアスがエイリアスと同一であることが保証されているかどうかは不明です同じAPI、または指定された狭い方法でのみ使用可能
実装での入力を節約するためだけに、パブリックAPIにエイリアスを配置しないでください。クライアントが使用することを意図している場合にのみ行ってください。
パブリックエイリアスを定義するときは、現在エイリアスされているタイプと常に同じであることが保証されているかどうか、またはより制限された互換性が意図されているかどうかなど、新しい名前の意図を文書化します。これにより、ユーザーは型を代替可能として扱うことができるかどうか、またはより具体的なルールに従う必要があるかどうかを知ることができ、実装がエイリアスを変更するためのある程度の自由度を維持するのに役立ちます。
パブリックAPIに名前空間エイリアスを配置しないでください。（名前空間も参照してください）。
たとえば、これらのエイリアスは、クライアントコードでの使用がどのように意図されているかを文書化しています。
これらのエイリアスは使用目的を文書化しておらず、それらの半分はクライアントでの使用を目的としていません。
ただし、ローカルの便利なエイリアスは、関数定義、クラスのプライベートセクション、明示的にマークされた内部名前空間、および.ccファイルでは問題ありません。
##包括的言語
ネーミングやコメントを含むすべてのコードでは、包括的言語を使用し、他のプログラマーが無礼または不快に感じる可能性のある用語（「マスター」と「スレーブ」、「ブラックリスト」と「ホワイトリスト」、「レッドライン」など）を避けます。これらの用語は、表面上は中立的な意味も持っています。同様に、特定の人を指す場合（およびその代名詞を使用する場合）を除いて、性別に依存しない言語を使用します。たとえば、性別が特定されていない人には「they」/「them」/「their」を使用します（[単数の場合でも]（https://apastyle.apa.org/style-grammar-guidelines/grammar/singular-they））、およびソフトウェア、コンピューター、およびその他の人ではないものの場合は「it」/「its」。
##ネーミング
最も重要な整合性ルールは、命名を管理するルールです。名前のスタイルは、そのエンティティの宣言を検索しなくても、名前付きエンティティがどのようなものであるか（タイプ、変数、関数、定数、マクロなど）を即座に通知します。私たちの脳のパターンマッチングエンジンは、これらの命名規則に大きく依存しています。
命名規則はかなり恣意的ですが、この分野では個人の好みよりも一貫性が重要であると考えているため、それらが賢明であるかどうかに関係なく、規則が規則です。
###一般的な命名規則
別のチームの人にもわかりやすい名前を使用して、読みやすさを最適化します。
オブジェクトの目的または意図を説明する名前を使用してください。新しいリーダーがコードをすぐに理解できるようにすることがはるかに重要であるため、水平方向のスペースを節約することについて心配する必要はありません。プロジェクト外の誰かに知られていない可能性のある略語（特に頭字語や頭字語）の使用を最小限に抑えます。単語内の文字を削除して省略しないでください。経験則として、ウィキペディアにリストされている場合、略語はおそらく問題ありません。一般的に言えば、説明性は名前の可視性の範囲に比例する必要があります。たとえば、 `n`は5行の関数内では適切な名前ですが、クラスのスコープ内ではあいまいすぎる可能性があります。
反復変数の「i」やテンプレートパラメータの「T」など、一般的に知られている特定の略語は問題ないことに注意してください。
以下の命名規則の目的上、「単語」とは、内部スペースなしで英語で書くものを指します。これには、頭字語やイニシャリズムなどの略語が含まれます。大文字と小文字が混在して書かれた名前の場合（「[キャメルケース]（https://en.wikipedia.org/wiki/Camel_case）」または「[パスカルケース]（https://en.wiktionary.org/」とも呼ばれる）wiki / Pascal_case） "）では、各単語の最初の文字が大文字になり、「StartRPC（）」ではなく「StartRpc（）」のように、略語を単一の単語として大文字にすることを好みます。
テンプレートパラメータは、カテゴリの命名スタイルに従う必要があります。タイプテンプレートパラメータは、タイプ名の規則に従う必要があり、非タイプテンプレートパラメータは、変数名の規則に従う必要があります。
###ファイル名
ファイル名はすべて小文字にする必要があり、アンダースコア（ `_`）またはダッシュ（` -`）を含めることができます。プロジェクトで使用されている規則に従ってください。従うべき一貫したローカルパターンがない場合は、「_」を選択します。
受け入れ可能なファイル名の例：
* `my_useful_class.cc` *` my-useful-class.cc` * `myusefulclass.cc` *` myusefulclass_test.cc // _ unittestと_regtestは非推奨です。`
C ++ファイルは `.cc`で終わり、ヘッダーファイルは` .h`で終わる必要があります。特定のポイントにテキストで含まれることに依存するファイルは、 `.inc`で終わる必要があります（自己完結型ヘッダーのセクションも参照してください）。
`db.h`など、` / usr / include`にすでに存在するファイル名は使用しないでください。
一般に、ファイル名は非常に具体的にします。たとえば、 `logs.h`ではなく` http_server_logs.h`を使用します。非常に一般的なケースは、「foo_bar.h」と「foo_bar.cc」などのファイルのペアを使用して、「FooBar」というクラスを定義することです。
###タイプ名
タイプ名は大文字で始まり、新しい単語ごとに大文字があり、アンダースコアはありません： `MyExcitingClass`、` MyExcitingEnum`。
すべての型の名前（クラス、構造体、型エイリアス、列挙型、および型テンプレートパラメータ）には、同じ命名規則があります。タイプ名は大文字で始まり、新しい単語ごとに大文字が必要です。アンダースコアはありません。例えば：
###変数名
変数の名前（関数パラメーターを含む）とデータメンバーはすべて小文字で、単語の間にアンダースコアが付いています。クラスのデータメンバー（構造体ではない）には、さらに下線が付いています。例： `a_local_variable`、` a_struct_data_member`、 `a_class_data_member_`。
####一般的な変数名
例えば：
####クラスデータメンバー
クラスのデータメンバーは、静的および非静的の両方で、通常の非メンバー変数と同じように名前が付けられますが、末尾にアンダースコアが付いています。
####構造体データメンバー
構造体のデータメンバーは、静的および非静的の両方で、通常の非メンバー変数と同じように名前が付けられます。クラスのデータメンバーが持つ末尾の下線はありません。
構造体とクラスをいつ使用するかについては、「構造体とクラス」を参照してください。
###定数名
constexprまたはconstと宣言され、その値がプログラムの期間中固定されている変数は、先頭に「k」が続き、その後に大文字と小文字が混在する名前が付けられます。大文字と小文字を区別できないまれなケースでは、アンダースコアを区切り文字として使用できます。例えば：
静的ストレージ期間を持つこのようなすべての変数（つまり、静的およびグローバル、詳細については[ストレージ期間]（http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration）を参照）は、このように名前を付ける必要があります。この規則は、自動変数などの他のストレージクラスの変数ではオプションです。それ以外の場合は、通常の変数命名規則が適用されます。
###関数名
通常の関数には大文字と小文字が混在しています。アクセサーとミューテーターは、変数のように名前を付けることができます。
通常、関数は大文字で始まり、新しい単語ごとに大文字が必要です。
（APIの一部として公開され、関数ではなくオブジェクトであるという事実は重要でない実装の詳細であるため、関数のように見えることを目的としたクラススコープ定数と名前空間スコープ定数にも同じ命名規則が適用されます。）
アクセサーとミューテーター（get関数とset関数）は、変数のように名前を付けることができます。これらは多くの場合、実際のメンバー変数に対応しますが、これは必須ではありません。たとえば、 `int count（）`や `void set_count（int count）`です。
###名前空間名
名前空間名はすべて小文字で、単語はアンダースコアで区切られています。トップレベルの名前空間名は、プロジェクト名に基づいています。ネストされた名前空間とよく知られているトップレベルの名前空間の間の衝突を回避します。
トップレベルの名前空間の名前は、通常、その名前空間にコードが含まれているプロジェクトまたはチームの名前である必要があります。その名前空間のコードは通常、ベース名が名前空間名と一致するディレクトリ（またはそのサブディレクトリ）にある必要があります。
省略名に対する規則は、変数名と同じように名前空間にも適用されることに注意してください。名前空間内のコードで名前空間名を指定する必要はほとんどないため、通常、省略形は特に必要ありません。
よく知られているトップレベルの名前空間と一致するネストされた名前空間は避けてください。名前空間名間の衝突は、名前ルックアップルールのために驚くべきビルドブレークにつながる可能性があります。特に、ネストされた `std`名前空間を作成しないでください。`websearch :: util`のような衝突しやすい名前よりも、一意のプロジェクト識別子（` websearch :: index`、 `websearch :: index_util`）を優先します。
`internal`名前空間の場合、同じ` internal`名前空間に他のコードが追加されて衝突が発生することに注意してください（チーム内の内部ヘルパーは関連している傾向があり、衝突につながる可能性があります）。このような状況では、ファイル名を使用して一意の内部名を作成すると便利です（ `frobber.h`で使用する` websearch :: index :: frobber_internal`）
###列挙子名
列挙子（スコープ付き列挙型とスコープなし列挙型の両方）には、マクロではなく定数のように名前を付ける必要があります。つまり、 `ENUM_NAME`ではなく` kEnumName`を使用します。
2009年1月までは、マクロのように列挙値に名前を付けるスタイルでした。これにより、列挙値とマクロ間の名前の衝突で問題が発生しました。そのため、定数スタイルの命名を優先するように変更されました。新しいコードでは、定数スタイルの命名を使用する必要があります。
###マクロ名
あなたは本当にマクロを定義するつもりはありませんよね？そうした場合、それらは次のようになります： `MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE`。
マクロの説明を参照してください。一般に、マクロは使用しないでください。ただし、どうしても必要な場合は、すべて大文字とアンダースコアを付けて名前を付ける必要があります。
###命名規則の例外
既存のCまたはC ++エンティティに類似した名前を付ける場合は、既存の命名規則スキームに従うことができます。
`bigopen（）`
関数名は、 `open（）` `uint`の形式に従います
`typedef`` bigpos`
`struct`または` class`は、 `pos``sparse_hash_map`の形式に従います。
STLのようなエンティティ。STL命名規則 `LONGLONG_MAX`に従います
`INT_MAX`のように定数
##コメント
コメントは、コードを読みやすくするために絶対に不可欠です。次のルールは、コメントする内容と場所を示しています。ただし、コメントは非常に重要ですが、最良のコードは自己文書化です。型や変数にわかりやすい名前を付けることは、コメントで説明しなければならないあいまいな名前を使用するよりもはるかに優れています。
あなたのコメントを書くとき、あなたの聴衆のために書いてください：あなたのコードを理解する必要がある次の貢献者。寛大になりましょう—次はあなたかもしれません！
###コメントスタイル
一貫性がある限り、 `//`または `/ * * /`構文を使用してください。
`//`または `/ * * /`構文のいずれかを使用できます。ただし、 `//`の方がはるかに一般的です。コメントの方法と、どこでどのスタイルを使用するかを一貫してください。
###ファイルコメント
ライセンスボイラープレートで各ファイルを開始します。
ファイルコメントは、ファイルの内容を説明します。ファイルが、宣言の時点でコメントによって文書化されている1つの抽象化を宣言、実装、またはテストする場合、ファイルのコメントは必要ありません。他のすべてのファイルにはファイルコメントが必要です。
####法的通知と著者ライン
すべてのファイルには、ライセンスの定型文が含まれている必要があります。プロジェクトで使用されるライセンスに適切なボイラープレートを選択します（たとえば、Apache 2.0、BSD、LGPL、GPL）。
著者行のあるファイルに大幅な変更を加える場合は、著者行を削除することを検討してください。新しいファイルには通常、著作権表示や作成者の行を含めるべきではありません。
####ファイルの内容
`.h`が複数の抽象化を宣言している場合、ファイルレベルのコメントは、ファイルの内容と、抽象化がどのように関連しているかを大まかに説明する必要があります。1文または2文のファイルレベルのコメントで十分な場合があります。個々の抽象化に関する詳細なドキュメントは、ファイルレベルではなく、それらの抽象化に属します。
`.h`と` .cc`の両方でコメントを複製しないでください。重複したコメントは分岐します。
###クラスコメント
すべての非自明なクラスまたは構造体宣言には、その目的と使用方法を説明するコメントを添付する必要があります。
クラスコメントは、クラスをいつどのように使用するかを知るのに十分な情報と、クラスを正しく使用するために必要な追加の考慮事項を読者に提供する必要があります。クラスが行う同期の仮定がある場合は、それを文書化します。クラスのインスタンスに複数のスレッドからアクセスできる場合は、マルチスレッドの使用を取り巻くルールと不変条件を文書化するように特に注意してください。
クラスコメントは、クラスの単純で焦点を絞った使用法を示す小さなサンプルコードスニペットに適した場所であることがよくあります。
十分に分離されている場合（たとえば、 `.h`ファイルと` .cc`ファイル）、クラスの使用法を説明するコメントは、そのインターフェイス定義と一緒にする必要があります。クラスの操作と実装に関するコメントは、クラスのメソッドの実装に付随する必要があります。
###関数コメント
宣言コメントは、関数の使用法を説明します（それが自明でない場合）。関数の定義のコメントは、操作を説明します。
####関数宣言
ほとんどすべての関数宣言の直前に、関数の機能と使用方法を説明するコメントが必要です。これらのコメントは、関数が単純で明白な場合にのみ省略できます（たとえば、クラスの明白なプロパティの単純なアクセサー）。これらのコメントは、命令法（「ファイルを開く」）の動詞ではなく、直説法（「ファイルを開く」）の説明的な動詞で開く必要があります。コメントは機能を説明しています。関数に何をすべきかを指示しません。一般に、これらのコメントは、関数がそのタスクを実行する方法を説明していません。代わりに、それは関数定義のコメントに任せるべきです。
関数宣言のコメントで言及するものの種類：
*入力と出力は何ですか。関数の引数名が `backticks`で提供されている場合、コードインデックスツールはドキュメントをより適切に表示できる可能性があります。*クラスメンバー関数の場合：オブジェクトがメソッド呼び出しの期間を超えて参照引数を記憶するかどうか、およびそれらを解放するかどうか。*関数が、呼び出し元が解放する必要のあるメモリを割り当てる場合。*引数のいずれかがnullポインタになる可能性があるかどうか。*関数の使用方法にパフォーマンスへの影響がある場合。*関数が再入可能である場合。その同期の前提は何ですか？
次に例を示します。
ただし、不必要に冗長にしたり、完全に明白なことを述べたりしないでください。
関数のオーバーライドを文書化するときは、オーバーライドされた関数からのコメントを繰り返すのではなく、オーバーライド自体の詳細に焦点を合わせてください。これらの多くの場合、オーバーライドには追加のドキュメントは必要ないため、コメントは必要ありません。
コンストラクタとデストラクタにコメントするときは、コードを読んでいる人がコンストラクタとデストラクタの目的を知っているので、「このオブジェクトを破棄する」などのコメントは役に立ちません。コンストラクターが引数を使用して行うこと（たとえば、ポインターの所有権を取得する場合）、およびデストラクタが行うクリーンアップを文書化します。これが些細なことである場合は、コメントをスキップしてください。デストラクタがヘッダーコメントを持たないことは非常に一般的です。
####関数の定義
関数がその仕事をどのように行うかについて何か注意が必要な場合は、関数定義に説明コメントを付ける必要があります。たとえば、定義コメントでは、使用するコーディングトリックを説明したり、実行した手順の概要を説明したり、実行可能な代替手段を使用するのではなく、実行した方法で関数を実装することを選択した理由を説明したりできます。たとえば、関数の前半でロックを取得する必要があるのに、後半でロックが不要な理由について説明する場合があります。
`.h`ファイルなど、関数宣言で指定されたコメントを繰り返すだけではいけないことに注意してください。関数が何をするかを簡単に要約することは問題ありませんが、コメントの焦点はそれがどのように機能するかにあるべきです。
###可変コメント
一般に、変数の実際の名前は、変数が何に使用されるかを理解するのに十分な説明が必要です。場合によっては、さらにコメントが必要になります。
####クラスデータメンバー
各クラスデータメンバー（インスタンス変数またはメンバー変数とも呼ばれます）の目的は明確である必要があります。タイプと名前で明確に表現されていない不変条件（特別な値、メンバー間の関係、存続期間の要件）がある場合は、コメントする必要があります。ただし、タイプと名前で十分な場合（ `int num_events _;`）、コメントは必要ありません。
特に、nullptrや-1などの番兵値が明確でない場合は、その存在と意味を説明するコメントを追加します。例えば：
####グローバル変数
すべてのグローバル変数には、それらが何であるか、それらが何に使用されるか、および（不明な場合）なぜグローバルである必要があるのかを説明するコメントが必要です。例えば：
###実装コメント
実装では、コードのトリッキー、非自明、興味深い、または重要な部分にコメントを付ける必要があります。
####説明コメント
トリッキーまたは複雑なコードブロックの前にコメントを付ける必要があります。例：
####行末のコメント
また、自明でない行は、行の最後にコメントを付ける必要があります。これらの行末コメントは、コードと2つのスペースで区切る必要があります。例：
コードの実行内容を説明するコメントと、関数が戻ったときにエラーがすでにログに記録されていることを示すコメントの両方があることに注意してください。
####関数の引数のコメント
関数の引数の意味が自明でない場合は、次のいずれかの解決策を検討してください。
*引数がリテラル定数であり、同じ定数が複数の関数呼び出しで暗黙のうちに同じであると想定する方法で使用されている場合は、名前付き定数を使用してその制約を明示的にし、それが保持されることを保証する必要があります。 *関数のシグネチャを変更して `bool`引数を` enum`引数に置き換えることを検討してください。これにより、引数の値が自己記述的になります。 *複数の構成オプションがある関数の場合、すべてのオプションを保持する単一のクラスまたは構造体を定義し、そのインスタンスを渡すことを検討してください。このアプローチにはいくつかの利点があります。オプションは、呼び出しサイトで名前で参照され、その意味が明確になります。また、関数の引数数が減り、関数呼び出しの読み取りと書き込みが容易になります。追加の利点として、別のオプションを追加するときに通話サイトを変更する必要はありません。 *大きなまたは複雑なネストされた式を名前付き変数に置き換えます。 *最後の手段として、コメントを使用して、呼び出しサイトでの引数の意味を明確にします。
次の例を考えてみましょう。
対：
####禁止事項
明白なことを述べないでください。特に、C ++をよく理解している読者にとって動作が自明でない場合を除いて、コードの機能を文字通り説明しないでください。代わりに、コードが何をするのかを説明する高レベルのコメントを提供するか、コードを自己記述的にします。
これを比較してください：
これに：
自己記述型のコードにはコメントは必要ありません。上記の例からのコメントは明らかです：
###句読点、スペル、および文法
句読点、スペル、および文法に注意してください。よく書かれたコメントは、よく書かれていないコメントよりも読みやすいです。
コメントは、適切な大文字と句読点を使用して、説明テキストと同じくらい読みやすくする必要があります。多くの場合、完全な文は文の断片よりも読みやすくなります。コード行の最後のコメントなど、短いコメントは形式的でない場合がありますが、スタイルに一貫性を持たせる必要があります。
セミコロンを使用する必要があるときにコンマを使用していることをコードレビューアに指摘させるのはイライラするかもしれませんが、ソースコードが高レベルの明快さと読みやすさを維持することは非常に重要です。適切な句読点、スペル、および文法は、その目標に役立ちます。
###すべてのコメント
一時的なコード、短期的な解決策、または十分ではあるが完全ではないコードには、 `TODO`コメントを使用します。
`TODO`には、文字列` TODO`をすべて大文字で含め、その後に名前、電子メールアドレス、バグID、またはその他の人物の識別子を含めるか、 `TODO`によって参照される問題に関する最適なコンテキストを使用する必要があります。主な目的は、要求に応じて詳細を取得する方法を見つけるために検索できる一貫した「TODO」を用意することです。「TODO」は、参照された人が問題を解決するという約束ではありません。したがって、名前を付けて「TODO」を作成する場合、ほとんどの場合、名前が付けられます。
`TODO`が「将来の日付で何かをする」という形式の場合は、非常に具体的な日付（「2005年11月までに修正」）または非常に具体的なイベント（「すべてのクライアントが処理できるときにこのコードを削除する」）を含めるようにしてくださいXML応答。」）。
##フォーマット
コーディングスタイルとフォーマットはかなり恣意的ですが、全員が同じスタイルを使用すると、プロジェクトを簡単に追跡できます。個人がフォーマットルールのすべての側面に同意するわけではなく、ルールの中には慣れが必要なものもありますが、すべてのプロジェクト貢献者がスタイルルールに従って、全員のコードを簡単に読んで理解できるようにすることが重要です。
コードを正しくフォーマットできるように、[emacsの設定ファイル]（https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el）を作成しました。
###線の長さ
コード内のテキストの各行は、最大80文字の長さである必要があります。
このルールは物議を醸すものであると認識していますが、既存のコードの多くがすでにこのルールに準拠しており、一貫性が重要であると感じています。
このルールを支持する人々は、ウィンドウのサイズを変更するように強制するのは失礼であり、これ以上何もする必要はないと主張しています。一部の人々は、いくつかのコードウィンドウを並べて配置することに慣れているため、どのような場合でもウィンドウを広げる余地がありません。人々は特定の最大ウィンドウ幅を想定して作業環境を設定し、80列が従来の標準でした。なぜそれを変更するのですか？
変更の支持者は、行を広くするとコードが読みやすくなると主張しています。80列の制限は、1960年代のメインフレームへの隠れた先祖返りです。最新の機器は、長い線を簡単に表示できるワイドスクリーンを備えています。
最大80文字です。
1行が80文字を超える場合があります
*読みやすさ、切り取りと貼り付けのしやすさ、または自動リンクを損なうことなく分割できないコメント行-たとえば、行にサンプルコマンドまたは80文字を超えるリテラルURLが含まれている場合。*内容が80文字を超える生の文字列リテラル。テストコードを除いて、そのようなリテラルはファイルの先頭近くに表示されます。* includeステートメント。*ヘッダーガード* using宣言
###非ASCII文字
非ASCII文字はまれであり、UTF-8形式を使用する必要があります。
英語であっても、ユーザー向けのテキストをソースにハードコーディングしないでください。そのため、非ASCII文字の使用はまれです。ただし、場合によっては、そのような単語をコードに含めることが適切です。たとえば、コードが外部ソースからのデータファイルを解析する場合、それらのデータファイルで使用される非ASCII文字列を区切り文字としてハードコーディングすることが適切な場合があります。より一般的には、ユニットテストコード（ローカライズする必要はありません）に非ASCII文字列が含まれる場合があります。このような場合は、UTF-8を使用する必要があります。これは、ASCII以外の処理も可能なほとんどのツールで理解できるエンコーディングであるためです。
16進エンコードもOKであり、読みやすさを向上させる場合に推奨されます。たとえば、 `" \ xEF \ xBB \ xBF "`、またはさらに簡単に言えば、 `u8" \ uFEFF "`は、Unicodeのゼロ幅ノーブレークです。スペース文字。ストレートUTF-8としてソースに含まれている場合は表示されません。
`u8`プレフィックスを使用して、` \ uXXXX`エスケープシーケンスを含む文字列リテラルがUTF-8としてエンコードされることを保証します。コンパイラがソースファイルをUTF-8として解釈しない場合、誤った出力が生成されるため、UTF-8としてエンコードされた非ASCII文字を含む文字列には使用しないでください。
C ++ 11の `char16_t`および` char32_t`文字タイプは、UTF-8以外のテキスト用であるため、使用しないでください。同様の理由で、 `wchar_t`も使用しないでください（` wchar_t`を広範囲に使用するWindowsAPIと対話するコードを記述している場合を除く）。
###スペースとタブ
スペースのみを使用し、一度に2つのスペースをインデントします。
インデントにはスペースを使用します。コードでタブを使用しないでください。Tabキーを押したときにスペースを出力するように、エディターを設定する必要があります。
###関数の宣言と定義
関数名と同じ行に戻り値の型、該当する場合は同じ行にパラメーターを返します。関数呼び出しで引数をラップするように、1行に収まらないパラメーターリストをラップします。
関数は次のようになります。
テキストが多すぎて1行に収まらない場合：
または、最初のパラメーターでも適合できない場合：
注意すべきいくつかのポイント：
*適切なパラメータ名を選択してください。※パラメータ名は、関数の定義で使用されていない場合のみ省略できます。*戻り値の型と関数名を1行に収めることができない場合は、それらの間を区切ります。*関数宣言または定義の戻り値の型の後で中断する場合は、インデントしないでください。*開き括弧は、常に関数名と同じ行にあります。*関数名と開き括弧の間にスペースを入れることはできません。*括弧とパラメーターの間にスペースが入ることはありません。*中括弧は常に関数宣言の最後の行の終わりにあり、次の行の始まりではありません。*閉じた中括弧は、それ自体で最後の行にあるか、開いた中括弧と同じ行にあります。*閉じ括弧と開いた中括弧の間にはスペースが必要です。*可能であれば、すべてのパラメータを調整する必要があります。*デフォルトのインデントは2スペースです。*ラップされたパラメータには4つのスペースインデントがあります。
コンテキストから明らかな未使用のパラメーターは省略できます。
明らかでない可能性のある未使用のパラメーターは、関数定義の変数名をコメントアウトする必要があります。
属性、および属性に展開されるマクロは、関数の宣言または定義の最初の戻り値の型の前に表示されます。
###ラムダ式
他の関数と同様にパラメーターと本体をフォーマットし、他のコンマ区切りリストと同様にリストをキャプチャします。
参照によるキャプチャの場合、アンパサンド（＆）と変数名の間にスペースを入れないでください。
短いラムダは、関数の引数としてインラインで記述できます。
###浮動小数点リテラル
浮動小数点リテラルは、指数表記を使用している場合でも、常に基数ポイントを持ち、両側に数字が必要です。すべての浮動小数点リテラルがこの使い慣れた形式をとると、読みやすさが向上します。これにより、整数リテラルと間違えられたり、指数表記の `E` /` e`が16進数と間違えられたりすることがなくなります。浮動小数点変数を整数リテラルで初期化することは問題ありませんが（変数タイプがその整数を正確に表すことができると仮定して）、指数表記の数値が整数リテラルになることはないことに注意してください。
###関数呼び出し
呼び出しをすべて1行に書き込むか、括弧で引数を折り返すか、4つのスペースでインデントされた新しい行で引数を開始し、その4つのスペースのインデントで続行します。他の考慮事項がない場合は、必要に応じて各行に複数の引数を配置するなど、最小行数を使用してください。
関数呼び出しの形式は次のとおりです。
引数がすべて1行に収まらない場合は、複数の行に分割し、後続の各行を最初の引数に揃える必要があります。開いたパレンの後または閉じたパレンの前にスペースを追加しないでください。
オプションで、引数はすべて、4つのスペースインデントを使用して後続の行に配置できます。
特定の可読性の問題がない限り、関数を呼び出すために必要な行数を減らすために、1行に複数の引数を置きます。各行に厳密に1つの引数を使用してフォーマットすると、読みやすくなり、引数の編集が簡単になるという意見もあります。ただし、引数の編集のしやすさよりも読者を優先し、ほとんどの読みやすさの問題は、次の手法でより適切に対処できます。
1行に複数の引数があると、一部の引数を構成する式の複雑さや紛らわしい性質のために読みやすさが低下する場合は、説明的な名前でそれらの引数をキャプチャする変数を作成してみてください。
または、説明的なコメントを付けて、紛らわしい議論を独自の行に配置します。
1つの引数がそれ自体の行で大幅に読みやすくなる場合がまだある場合は、それを独自の行に配置します。決定は、一般的な方針ではなく、より読みやすくされた議論に固有のものでなければなりません。
引数は、読みやすさにとって重要な構造を形成する場合があります。そのような場合は、その構造に従って引数を自由にフォーマットしてください。
###ブレース初期化子リスト形式
ブレース付き初期化子リストを、その場所で関数呼び出しをフォーマットするのとまったく同じようにフォーマットします。
ブレースリストの後に名前（タイプ名や変数名など）が続く場合は、 `{}`がその名前の関数呼び出しの括弧であるかのようにフォーマットします。名前がない場合は、長さがゼロの名前を想定してください。
###条件付き
オプションの `elseif`句と` else`句を含む `if`ステートメントで、` if`と開き括弧の間、および閉じ括弧と中括弧（存在する場合）の間にスペースを1つ入れますが、スペースは入れません。括弧と条件または初期化子の間。オプションの初期化子が存在する場合は、セミコロンの前にスペースまたは改行を入れてください。
`if`、` else if`、および `else`に続く制御ステートメントには中括弧を使用します。開始ブレースの直後、および終了ブレースの直前で線を引きます。後続の `else`は、もしあれば、前の閉じ中括弧と同じ行にスペースで区切られて表示されます。
歴史的な理由から、上記の規則に1つの例外を認めます。`if`ステートメントに `else`または` else if`句がない場合、制御されたステートメントの中括弧または中括弧内の改行は省略できます。結果として、 `if`ステートメント全体が1行（この場合は閉じ括弧と制御されたステートメントの間にスペースがあります）または2行（この場合は閉じ括弧の後に改行があります）のいずれかに表示されます。中括弧はありません）。たとえば、この例外では次のフォームが許可されます。
このスタイルは、ステートメントが短い場合にのみ使用してください。複雑な条件を持つ条件ステートメントまたは制御されたステートメントは、中括弧を使用すると読みやすくなる可能性があることを考慮してください。一部のプロジェクトでは、常に中括弧が必要です。
最後に、これらは許可されていません。
###ループとSwitchステートメント
switchステートメントでは、ブロックに中括弧を使用できます。ケース間の重要なフォールスルーに注釈を付けます。中括弧は、単一ステートメントのループではオプションです。空のループ本体は、空の中括弧または「続行」のいずれかを使用する必要があります。
`switch`ステートメントの` case`ブロックには、好みに応じて中括弧を付けるかどうかを指定できます。中括弧を含める場合は、以下に示すように配置する必要があります。
列挙値を条件としない場合、switchステートメントには常に「デフォルト」の大文字と小文字を区別する必要があります（列挙値の場合、値が処理されない場合はコンパイラーが警告します）。デフォルトのケースが実行されない場合は、これをエラーとして扱います。例えば：
あるケースラベルから別のケースラベルへのフォールスルーは、 `ABSL_FALLTHROUGH_INTENDED;`マクロ（ `absl / base / macros.h`で定義）を使用して注釈を付ける必要があります。`ABSL_FALLTHROUGH_INTENDED;`は、次のケースラベルへのフォールスルーが発生する実行ポイントに配置する必要があります。一般的な例外は、コードが介在しない連続したケースラベルです。この場合、注釈は必要ありません。
中括弧は、単一ステートメントのループではオプションです。
空のループ本体では、単一のセミコロンではなく、中括弧の空のペアを使用するか、中括弧なしで「続行」する必要があります。
###ポインタと参照式
ピリオドまたは矢印の周りにスペースはありません。ポインター演算子には末尾のスペースはありません。
以下は、正しくフォーマットされたポインターおよび参照式の例です。
ご了承ください：
*メンバーにアクセスするときは、ピリオドまたは矢印の周りにスペースはありません。*ポインタ演算子は `*`または `＆`の後にスペースがありません。
ポインターまたは参照変数または引数を宣言するときは、タイプまたは変数名のいずれかに隣接してアスタリスク/アンパサンドを配置できます。
これは単一のファイル内で一貫して行う必要があるため、既存のファイルを変更するときは、そのファイルのスタイルを使用してください。
（異常な場合）同じ宣言で複数の変数を宣言することは許可されていますが、それらのいずれかにポインターまたは参照の装飾がある場合は許可されません。そのような宣言は簡単に誤解されます。
###ブール式
標準の行の長さよりも長いブール式がある場合は、行の分割方法に一貫性を持たせてください。
この例では、論理AND演算子は常に行末にあります。
この例でコードが折り返される場合、両方の `&&`論理AND演算子が行の終わりにあることに注意してください。これはGoogleコードでより一般的ですが、行の先頭ですべての演算子をラップすることもできます。かっこは、適切に使用すると読みやすさを向上させるのに非常に役立つため、慎重に挿入してください。ただし、使いすぎには注意してください。また、「and」や「compl」などの単語演算子ではなく、「&&」や「〜」などの句読点演算子を常に使用する必要があることにも注意してください。
###戻り値
`return`式を不必要に括弧で囲まないでください。
`return expr;`で括弧を使用するのは、 `x = expr;`で使用する場合のみです。
###変数と配列の初期化
`=`、 `（）`、および `{}`から選択できます。以下はすべて正しいです：
`std :: initializer_list`コンストラクターを持つ型でブレース付き初期化リスト` {...} `を使用する場合は注意してください。空でない_braced-init-list_は、可能な限り `std :: initializer_list`コンストラクターを優先します。空の中括弧 `{}`は特別であり、使用可能な場合はデフォルトのコンストラクターを呼び出すことに注意してください。非 `std :: initializer_list`コンストラクターを強制するには、中括弧の代わりに括弧を使用します。
また、ブレース形状により、一体型の狭まりを防ぎます。これにより、一部のタイプのプログラミングエラーを防ぐことができます。
###プリプロセッサディレクティブ
プリプロセッサディレクティブを開始するハッシュマークは、常に行の先頭にある必要があります。
プリプロセッサディレクティブがインデントされたコードの本体内にある場合でも、ディレクティブは行の先頭から開始する必要があります。
###クラス形式
`public`、` protected`、および `private`の順序のセクションは、それぞれ1つのスペースをインデントします。
クラス定義の基本的な形式（コメントがない。必要なコメントの説明については、クラスコメントを参照）は次のとおりです。
注意事項：
*基本クラス名は、80列の制限に従い、サブクラス名と同じ行に配置する必要があります。* `public：`、 `protected：`、および `private：`キーワードは1スペースインデントする必要があります。*最初のインスタンスを除いて、これらのキーワードの前には空白行を付ける必要があります。このルールは、少人数のクラスではオプションです。*これらのキーワードの後に空白行を残さないでください。*最初に「public」セクション、次に「protected」、最後に「private」セクションを指定する必要があります。*これらの各セクション内の宣言の順序に関する規則については、宣言の順序を参照してください。
###コンストラクタ初期化子リスト
コンストラクター初期化子リストは、すべて1行にすることも、後続の行を4つのスペースでインデントすることもできます。
イニシャライザリストで使用できる形式は次のとおりです。
###名前空間のフォーマット
名前空間の内容はインデントされません。
名前空間は、余分なレベルのインデントを追加しません。たとえば、次を使用します。
名前空間内でインデントしないでください。
###水平方向の空白
水平方向の空白の使用は場所によって異なります。行末に末尾の空白を入れないでください。
####一般
末尾の空白を追加すると、既存の末尾の空白を削除する場合と同様に、同じファイルを編集する他のユーザーがマージするときに余分な作業が発生する可能性があります。したがって、末尾に空白を導入しないでください。その行をすでに変更している場合は削除するか、別のクリーンアップ操作で実行します（できれば、他の誰もファイルで作業していない場合）。
####ループと条件
####演算子
####テンプレートとキャスト
###垂直方向の空白
垂直方向の空白の使用を最小限に抑えます。
これはルールよりも原則です。必要がない場合は空白行を使用しないでください。特に、関数の間に1つまたは2つ以上の空白行を入れたり、関数を空白行で開始したり、関数を空白行で終了したりしないでください。また、空白行の使用を控えてください。コードブロック内の空白行は、散文の段落区切りのように機能します。つまり、2つの考えを視覚的に分離します。
基本的な原則は次のとおりです。1つの画面に収まるコードが多いほど、プログラムの制御フローを追跡して理解しやすくなります。意図的に空白を使用して、そのフローを分離します。
空白行が役立つ場合に役立ついくつかの目安：
*関数の最初または最後の空白行は、読みやすくなりません。* if-elseブロックのチェーン内の空白行は読みやすさを向上させる可能性があります。*コメント行の前の空白行は、通常、読みやすさを向上させます。新しいコメントの導入は、新しい考えの始まりを示唆し、空白行は、コメントが前ではなく次のことを伴うことを明確にします。*名前空間または名前空間のブロックの宣言のすぐ内側の空白行は、（主に非セマンティックな）組織ラッパーから耐荷重コンテンツを視覚的に分離することで読みやすくなる場合があります。特に、名前空間内の最初の宣言の前にコメントがある場合、これは前のルールの特殊なケースになり、コメントが後続の宣言に「添付」されるのに役立ちます。
##ルールの例外
上記のコーディング規約は必須です。ただし、すべての優れたルールと同様に、これらには例外がある場合があります。これについては、ここで説明します。
###既存の不適合コード
このスタイルガイドに準拠していないコードを扱う場合は、ルールから逸脱する可能性があります。
このガイドに示されている仕様以外の仕様で記述されたコードを変更していることに気付いた場合は、そのコードのローカル規則との一貫性を保つために、これらのルールから逸脱する必要があります。これを行う方法について疑問がある場合は、元の作成者または現在コードの責任者に問い合わせてください。_consistency_にはローカル整合性も含まれることに注意してください。
### Windowsコード
Windowsプログラマーは、主にWindowsヘッダーやその他のMicrosoftコードの規則から派生した、独自のコーディング規則のセットを開発しました。誰でも簡単にコードを理解できるようにしたいので、どのプラットフォームでもC ++を作成するすべての人のためのガイドラインを1つ用意しています。
一般的なWindowsスタイルに慣れている場合に忘れてしまう可能性のあるガイドラインのいくつかを繰り返す価値があります。
*ハンガリアン記法を使用しないでください（たとえば、整数の「iNum」に名前を付ける）。ソースファイルの拡張子 `.cc`を含むGoogleの命名規則を使用します。 * Windowsは、 `DWORD`、` HANDLE`などのプリミティブ型の独自の同義語の多くを定義しています。WindowsAPI関数を呼び出すときにこれらの型を使用することは完全に受け入れられ、推奨されます。それでも、基礎となるC ++タイプにできるだけ近づけてください。たとえば、 `LPCTSTR`の代わりに` const TCHAR * `を使用します。 * Microsoft Visual C ++でコンパイルする場合は、コンパイラを警告レベル3以上に設定し、すべての警告をエラーとして扱います。 * `#pragmaonce`は使用しないでください。代わりに、標準のGoogleインクルードガードを使用してください。インクルードガードのパスは、プロジェクトツリーの最上位を基準にする必要があります。 *実際、どうしても必要な場合を除いて、 `#pragma`や` __declspec`などの非標準の拡張子は使用しないでください。 `__declspec（dllimport）`と `__declspec（dllexport）`の使用は許可されています。ただし、コードを共有している場合に誰かが拡張機能を簡単に無効にできるように、 `DLLIMPORT`や` DLLEXPORT`などのマクロを介してそれらを使用する必要があります。
ただし、Windowsでときどき破る必要のあるルールがいくつかあります。
*通常、複数の実装の継承を使用することは強くお勧めしません。ただし、COMおよび一部のATL / WTLクラスを使用する場合は必須です。複数の実装継承を使用して、COMまたはATL / WTLクラスおよびインターフェースを実装できます。 *独自のコードで例外を使用するべきではありませんが、例外はATLおよびVisual C ++に付属するものを含む一部のSTLで広く使用されています。 ATLを使用する場合は、例外を無効にするために `_ATL_NO_EXCEPTIONS`を定義する必要があります。 STLで例外を無効にすることもできるかどうかを調査する必要がありますが、無効にできない場合は、コンパイラで例外をオンにしても問題ありません。 （これはSTLをコンパイルするためだけのものであることに注意してください。例外処理コードを自分で作成しないでください。）*プリコンパイル済みヘッダーを操作する通常の方法は、各ソースファイルの先頭にヘッダーファイルをインクルードすることです。 `StdAfx.h`や` precompile.h`のような名前。コードを他のプロジェクトと簡単に共有できるようにするには、このファイルを明示的に含めないようにし（ `precompile.cc`を除く）、` / FI`コンパイラオプションを使用してファイルを自動的に含めます。 *通常は `resource.h`という名前で、マクロのみを含むリソースヘッダーは、これらのスタイルガイドラインに準拠する必要はありません。
##別れの言葉
常識と_BECONSISTENT_を使用してください。
コードを編集している場合は、数分かけて周囲のコードを確認し、そのスタイルを判断してください。`if`句の前後にスペースを使用する場合は、あなたもそうすべきです。コメントの周りに小さな星のボックスがある場合は、コメントにも小さな星のボックスを配置します。
スタイルガイドラインを持つことのポイントは、人々があなたがそれをどのように言っているかではなく、あなたが言っていることに集中できるように、コーディングの共通の語彙を持つことです。ここではグローバルスタイルのルールを提示して、人々が語彙を理解できるようにします。しかし、地元のスタイルも重要です。ファイルに追加するコードがその周りの既存のコードと大幅に異なって見える場合、不連続性により、読者はファイルを読みに行くときにリズムが狂います。これを避けるようにしてください。
OK、コードの記述について十分に記述します。コード自体ははるかに興味深いものです。楽しんで！
* * *
